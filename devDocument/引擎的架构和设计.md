# MonsterEngine å¼•æ“æ¶æ„å’Œè®¾è®¡æ–‡æ¡£

## ç›®å½•
1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æ•´ä½“æ¶æ„](#æ•´ä½“æ¶æ„)
3. [æ ¸å¿ƒæ¨¡å—åˆ†æ](#æ ¸å¿ƒæ¨¡å—åˆ†æ)
4. [RHI æ¸²æŸ“ç¡¬ä»¶æ¥å£è®¾è®¡](#rhi-æ¸²æŸ“ç¡¬ä»¶æ¥å£è®¾è®¡)
5. [å¹³å°æŠ½è±¡å±‚](#å¹³å°æŠ½è±¡å±‚)
6. [ç±»å›¾å’Œå…³ç³»](#ç±»å›¾å’Œå…³ç³»)
7. [æ•°æ®æµç¨‹](#æ•°æ®æµç¨‹)
8. [è®¾è®¡æ¨¡å¼å’ŒåŸåˆ™](#è®¾è®¡æ¨¡å¼å’ŒåŸåˆ™)
9. [å†…å­˜ç®¡ç†ç­–ç•¥](#å†…å­˜ç®¡ç†ç­–ç•¥)
10. [æ€§èƒ½è€ƒè™‘](#æ€§èƒ½è€ƒè™‘)
11. [æ‰©å±•æ€§è®¾è®¡](#æ‰©å±•æ€§è®¾è®¡)

---

## é¡¹ç›®æ¦‚è¿°

MonsterEngine æ˜¯ä¸€ä¸ªåŸºäºç°ä»£C++20æ ‡å‡†å¼€å‘çš„æ¸²æŸ“å¼•æ“ï¼Œå…¶æ ¸å¿ƒæ¶æ„è®¾è®¡å‚è€ƒäº†è™šå¹»å¼•æ“5 (UE5) çš„RHI (Render Hardware Interface) æ¶æ„æ¨¡å¼ã€‚è¯¥å¼•æ“é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œå®ç°äº†è·¨å¹³å°å›¾å½¢APIçš„æŠ½è±¡ï¼Œç›®å‰ä¸»è¦æ”¯æŒVulkanåç«¯ï¼Œå¹¶ä¸ºæœªæ¥æ”¯æŒDirect3D 12ã€Direct3D 11ã€OpenGLå’ŒMetalç­‰å›¾å½¢APIå¥ å®šäº†åŸºç¡€ã€‚

æ‰€æœ‰ä»£ç å®ç°å‚è€ƒUE5,UE5æºç githubé“¾æ¥ï¼š@https://github.com/EpicGames/UnrealEngine 

### æ ¸å¿ƒè®¾è®¡ç›®æ ‡
- **è·¨å¹³å°æ”¯æŒ**: Windowsã€Linuxã€Android
- **å¤šå›¾å½¢APIæ”¯æŒ**: Vulkanã€D3D12ã€D3D11ã€OpenGLã€Metal
- **ç°ä»£C++è®¾è®¡**: ä½¿ç”¨C++20ç‰¹æ€§ï¼ŒRAIIåŸåˆ™ï¼Œæ™ºèƒ½æŒ‡é’ˆ
- **æ¨¡å—åŒ–æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚å’Œæ¨¡å—åŒ–è®¾è®¡
- **é«˜æ€§èƒ½æ¸²æŸ“**: GPUé©±åŠ¨æ¸²æŸ“ï¼Œæœ€å°åŒ–CPUå¼€é”€
- **è°ƒè¯•å‹å¥½**: å®Œå–„çš„è°ƒè¯•æ”¯æŒå’ŒéªŒè¯å±‚

---

## æ•´ä½“æ¶æ„

MonsterEngine é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œä»ä¸Šåˆ°ä¸‹åˆ†ä¸ºä»¥ä¸‹å‡ å±‚ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨å±‚ (Application)                    â”‚
â”‚              main.cpp + TriangleRenderer                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   å¼•æ“å±‚ (Engine)                        â”‚
â”‚                   Engine.h/cpp                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 é«˜çº§æ¸²æŸ“å±‚ (Renderer)                     â”‚
â”‚               Renderer Module (æœªæ¥æ‰©å±•)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ¸²æŸ“ç¡¬ä»¶æ¥å£å±‚ (RHI Layer)                    â”‚
â”‚    IRHIDevice â”‚ IRHICommandList â”‚ IRHIResource           â”‚
â”‚         RHI.h â”‚ RHIDefinitions.h â”‚ æŠ½è±¡æ¥å£               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             å¹³å°å®ç°å±‚ (Platform Layer)                    â”‚
â”‚   VulkanDevice â”‚ D3D12Device â”‚ OpenGLDevice (æœªæ¥)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å›¾å½¢APIå±‚ (Graphics APIs)                   â”‚
â”‚        Vulkan â”‚ Direct3D 12 â”‚ OpenGL â”‚ Metal           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¶æ„ç‰¹ç‚¹

1. **åˆ†å±‚è§£è€¦**: æ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼Œå±‚ä¸å±‚ä¹‹é—´é€šè¿‡æ¥å£é€šä¿¡
2. **æ¥å£æŠ½è±¡**: RHIå±‚æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œéšè—åº•å±‚å›¾å½¢APIå·®å¼‚
3. **å·¥å‚æ¨¡å¼**: ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºå¹³å°ç‰¹å®šçš„å®ç°
4. **RAIIç®¡ç†**: æ‰€æœ‰èµ„æºä½¿ç”¨RAIIåŸåˆ™ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
5. **ç°ä»£C++**: å¹¿æ³›ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆã€æ¨¡æ¿ã€æ¦‚å¿µç­‰C++20ç‰¹æ€§

---

## æ ¸å¿ƒæ¨¡å—åˆ†æ

### 1. Core æ¨¡å—

Core æ¨¡å—æä¾›å¼•æ“çš„åŸºç¡€è®¾æ–½å’Œå·¥å…·ç±»ï¼š

```cpp
Core/
â”œâ”€â”€ CoreMinimal.h        // æ ¸å¿ƒåŒ…å«æ–‡ä»¶
â”œâ”€â”€ CoreTypes.h          // åŸºç¡€ç±»å‹å®šä¹‰
â”œâ”€â”€ Log.h/.cpp          // æ—¥å¿—ç³»ç»Ÿ
â””â”€â”€ Assert.h            // æ–­è¨€ç³»ç»Ÿ
```

#### å…³é”®ç‰¹æ€§
- **ç±»å‹åˆ«å**: æä¾›UE5é£æ ¼çš„ç±»å‹åˆ«å (TSharedPtr, TUniquePtr, TArrayç­‰)
- **å¹³å°æ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹ç›®æ ‡å¹³å° (Windows, Linux)
- **æ—¥å¿—ç³»ç»Ÿ**: å¤šçº§åˆ«æ—¥å¿—æ”¯æŒ (DEBUG, INFO, WARNING, ERROR)
- **æ–­è¨€ç³»ç»Ÿ**: è°ƒè¯•ç‰ˆæœ¬çš„è¿è¡Œæ—¶æ£€æŸ¥

#### ç±»å‹ç³»ç»Ÿè®¾è®¡
```cpp
// æ™ºèƒ½æŒ‡é’ˆ (å‚è€ƒUE5è®¾è®¡)
template<typename T> using TSharedPtr = std::shared_ptr<T>;
template<typename T> using TUniquePtr = std::unique_ptr<T>;
template<typename T> using TWeakPtr = std::weak_ptr<T>;

// å®¹å™¨ç±»å‹
template<typename T> using TArray = std::vector<T>;
template<typename T> using TSpan = std::span<T>;
template<typename Key, typename Value> using TMap = std::unordered_map<Key, Value>;
```

### 2. RHI æ¨¡å—

RHI (Render Hardware Interface) æ¨¡å—æ˜¯å¼•æ“çš„æ ¸å¿ƒæ¸²æŸ“æŠ½è±¡å±‚ï¼š

```cpp
RHI/
â”œâ”€â”€ RHI.h                   // RHIå·¥å‚å’Œåˆ›å»ºä¿¡æ¯
â”œâ”€â”€ RHIDefinitions.h        // RHIç±»å‹å’Œæšä¸¾å®šä¹‰
â”œâ”€â”€ IRHIDevice.h           // è®¾å¤‡æ¥å£
â”œâ”€â”€ IRHICommandList.h      // å‘½ä»¤åˆ—è¡¨æ¥å£
â””â”€â”€ IRHIResource.h         // èµ„æºåŸºç±»æ¥å£
```

#### è®¾è®¡åŸåˆ™
- **æ¥å£åˆ†ç¦»**: æ¯ä¸ªåŠŸèƒ½éƒ½æœ‰ç‹¬ç«‹çš„æ¥å£
- **èµ„æºç®¡ç†**: ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æºç”Ÿå‘½å‘¨æœŸ
- **çŠ¶æ€è·Ÿè¸ª**: æ”¯æŒæ˜¾å¼èµ„æºçŠ¶æ€è½¬æ¢
- **è°ƒè¯•æ”¯æŒ**: å†…ç½®è°ƒè¯•äº‹ä»¶å’Œæ ‡è®°æ”¯æŒ

### 3. Platform æ¨¡å—

Platform æ¨¡å—åŒ…å«å„å›¾å½¢APIçš„å…·ä½“å®ç°ï¼š

```cpp
Platform/
â””â”€â”€ Vulkan/
    â”œâ”€â”€ VulkanRHI.h         // VulkanåŸºç¡€å®šä¹‰
    â”œâ”€â”€ VulkanDevice.h      // Vulkanè®¾å¤‡å®ç°
    â”œâ”€â”€ VulkanCommandList.h // Vulkanå‘½ä»¤åˆ—è¡¨
    â”œâ”€â”€ VulkanBuffer.h      // Vulkanç¼“å†²åŒº
    â”œâ”€â”€ VulkanTexture.h     // Vulkançº¹ç†
    â”œâ”€â”€ VulkanShader.h      // Vulkanç€è‰²å™¨
    â””â”€â”€ VulkanUtils.h       // Vulkanå·¥å…·å‡½æ•°
```

### 4. Engine æ¨¡å—

Engine æ¨¡å—æ˜¯å¼•æ“çš„ä¸»å…¥å£ç‚¹ï¼Œè´Ÿè´£åˆå§‹åŒ–å’Œç®¡ç†å„ä¸ªå­ç³»ç»Ÿï¼š

```cpp
class Engine {
public:
    bool initialize(const RHI::RHICreateInfo& rhiCreateInfo);
    void shutdown();
    void run();
    RHI::IRHIDevice* getRHIDevice() const;
    
private:
    TUniquePtr<RHI::IRHIDevice> m_rhiDevice;
    bool m_initialized = false;
    bool m_shouldRun = true;
};
```

---

## RHI æ¸²æŸ“ç¡¬ä»¶æ¥å£è®¾è®¡

RHIå±‚æ˜¯MonsterEngineçš„æ ¸å¿ƒè®¾è®¡ï¼Œå®ƒæä¾›äº†ç»Ÿä¸€çš„æ¸²æŸ“æ¥å£ï¼Œå±è”½äº†ä¸åŒå›¾å½¢APIä¹‹é—´çš„å·®å¼‚ã€‚

### RHI æ¶æ„å›¾

```mermaid
graph TB
    subgraph "RHI Interfaces"
        IRHIDevice["IRHIDevice<br/>è®¾å¤‡æ¥å£"]
        IRHICommandList["IRHICommandList<br/>å‘½ä»¤åˆ—è¡¨æ¥å£"]
        IRHIResource["IRHIResource<br/>èµ„æºåŸºç±»"]
        IRHIBuffer["IRHIBuffer<br/>ç¼“å†²åŒºæ¥å£"]
        IRHITexture["IRHITexture<br/>çº¹ç†æ¥å£"]
        IRHIShader["IRHIShader<br/>ç€è‰²å™¨æ¥å£"]
        IRHIPipelineState["IRHIPipelineState<br/>ç®¡é“çŠ¶æ€æ¥å£"]
    end
    
    subgraph "RHI Factory"
        RHIFactory["RHIFactory<br/>å·¥å‚ç±»"]
        RHICreateInfo["RHICreateInfo<br/>åˆ›å»ºå‚æ•°"]
    end
    
    subgraph "Platform Implementations"
        VulkanDevice["VulkanDevice"]
        VulkanCommandList["VulkanCommandList"]
        VulkanBuffer["VulkanBuffer"]
        D3D12Device["D3D12Device<br/>(è®¡åˆ’ä¸­)"]
        OpenGLDevice["OpenGLDevice<br/>(è®¡åˆ’ä¸­)"]
    end
    
    RHIFactory --> IRHIDevice
    IRHIDevice --> IRHICommandList
    IRHIDevice --> IRHIResource
    IRHIResource --> IRHIBuffer
    IRHIResource --> IRHITexture
    IRHIDevice --> IRHIShader
    IRHIDevice --> IRHIPipelineState
    
    IRHIDevice -.-> VulkanDevice
    IRHIDevice -.-> D3D12Device
    IRHIDevice -.-> OpenGLDevice
    IRHICommandList -.-> VulkanCommandList
    IRHIBuffer -.-> VulkanBuffer
```

### æ ¸å¿ƒæ¥å£è®¾è®¡

#### 1. IRHIDevice - è®¾å¤‡æ¥å£

IRHIDevice æ˜¯RHIå±‚çš„æ ¸å¿ƒæ¥å£ï¼Œè´Ÿè´£ç®¡ç†GPUè®¾å¤‡å’Œåˆ›å»ºå„ç§æ¸²æŸ“èµ„æºï¼š

```cpp
class IRHIDevice {
public:
    // è®¾å¤‡èƒ½åŠ›æŸ¥è¯¢
    virtual const RHIDeviceCapabilities& getCapabilities() const = 0;
    
    // èµ„æºåˆ›å»º
    virtual TSharedPtr<IRHIBuffer> createBuffer(const BufferDesc& desc) = 0;
    virtual TSharedPtr<IRHITexture> createTexture(const TextureDesc& desc) = 0;
    virtual TSharedPtr<IRHIVertexShader> createVertexShader(TSpan<const uint8> bytecode) = 0;
    virtual TSharedPtr<IRHIPixelShader> createPixelShader(TSpan<const uint8> bytecode) = 0;
    virtual TSharedPtr<IRHIPipelineState> createPipelineState(const PipelineStateDesc& desc) = 0;
    
    // å‘½ä»¤åˆ—è¡¨ç®¡ç†
    virtual TSharedPtr<IRHICommandList> createCommandList() = 0;
    virtual void executeCommandLists(TSpan<TSharedPtr<IRHICommandList>> commandLists) = 0;
    virtual IRHICommandList* getImmediateCommandList() = 0;
    
    // åŒæ­¥å’Œå‘ˆç°
    virtual void waitForIdle() = 0;
    virtual void present() = 0;
};
```

#### 2. IRHICommandList - å‘½ä»¤åˆ—è¡¨æ¥å£

IRHICommandList è´Ÿè´£è®°å½•æ¸²æŸ“å‘½ä»¤ï¼Œæ”¯æŒå»¶è¿Ÿæ‰§è¡Œï¼š

```cpp
class IRHICommandList {
public:
    // å‘½ä»¤è®°å½•æ§åˆ¶
    virtual void begin() = 0;
    virtual void end() = 0;
    virtual void reset() = 0;
    
    // èµ„æºç»‘å®š
    virtual void setPipelineState(TSharedPtr<IRHIPipelineState> pipelineState) = 0;
    virtual void setVertexBuffers(uint32 startSlot, TSpan<TSharedPtr<IRHIBuffer>> vertexBuffers) = 0;
    virtual void setIndexBuffer(TSharedPtr<IRHIBuffer> indexBuffer, bool is32Bit = true) = 0;
    
    // æ¸²æŸ“çŠ¶æ€è®¾ç½®
    virtual void setViewport(const Viewport& viewport) = 0;
    virtual void setScissorRect(const ScissorRect& scissorRect) = 0;
    virtual void setRenderTargets(TSpan<TSharedPtr<IRHITexture>> renderTargets,
                                TSharedPtr<IRHITexture> depthStencil = nullptr) = 0;
    
    // ç»˜åˆ¶å‘½ä»¤
    virtual void draw(uint32 vertexCount, uint32 startVertexLocation = 0) = 0;
    virtual void drawIndexed(uint32 indexCount, uint32 startIndexLocation = 0,
                           int32 baseVertexLocation = 0) = 0;
    
    // èµ„æºæ¸…ç†å’Œè½¬æ¢
    virtual void clearRenderTarget(TSharedPtr<IRHITexture> renderTarget, const float32 clearColor[4]) = 0;
    virtual void transitionResource(TSharedPtr<IRHIResource> resource, 
                                  EResourceUsage stateBefore, EResourceUsage stateAfter) = 0;
};
```

### RHI ç±»å‹ç³»ç»Ÿ

RHI å®šä¹‰äº†å®Œæ•´çš„ç±»å‹ç³»ç»Ÿæ¥æè¿°æ¸²æŸ“èµ„æºå’ŒçŠ¶æ€ï¼š

#### èµ„æºä½¿ç”¨æ ‡å¿—
```cpp
enum class EResourceUsage : uint32 {
    None = 0,
    VertexBuffer = 1 << 0,
    IndexBuffer = 1 << 1,
    UniformBuffer = 1 << 2,
    StorageBuffer = 1 << 3,
    TransferSrc = 1 << 4,
    TransferDst = 1 << 5,
    RenderTarget = 1 << 6,
    DepthStencil = 1 << 7,
    ShaderResource = 1 << 8,
    UnorderedAccess = 1 << 9
};
```

#### ç¼“å†²åŒºæè¿°
```cpp
struct BufferDesc {
    uint32 size = 0;
    EResourceUsage usage = EResourceUsage::None;
    bool cpuAccessible = false;
    String debugName;
};
```

#### çº¹ç†æè¿°
```cpp
struct TextureDesc {
    uint32 width = 1;
    uint32 height = 1;
    uint32 depth = 1;
    uint32 mipLevels = 1;
    uint32 arraySize = 1;
    EPixelFormat format = EPixelFormat::R8G8B8A8_UNORM;
    EResourceUsage usage = EResourceUsage::ShaderResource;
    String debugName;
};
```

### RHI å·¥å‚æ¨¡å¼

RHI ä½¿ç”¨å·¥å‚æ¨¡å¼æ¥åˆ›å»ºå¹³å°ç‰¹å®šçš„å®ç°ï¼š

```cpp
class RHIFactory {
public:
    static TUniquePtr<IRHIDevice> createDevice(const RHICreateInfo& createInfo);
    static TArray<ERHIBackend> getAvailableBackends();
    static bool isBackendAvailable(ERHIBackend backend);
    static const char* getBackendName(ERHIBackend backend);
    static ERHIBackend selectBestBackend();
};
```

#### RHIåˆ›å»ºä¿¡æ¯
```cpp
struct RHICreateInfo {
    ERHIBackend preferredBackend = ERHIBackend::Vulkan;
    bool enableValidation = false;
    bool enableDebugMarkers = true;
    String applicationName = "MonsterRender Application";
    uint32 applicationVersion = 1;
    void* windowHandle = nullptr;
    uint32 windowWidth = 1920;
    uint32 windowHeight = 1080;
};
```

---

## å¹³å°æŠ½è±¡å±‚

### Vulkan å®ç°

å½“å‰å¼•æ“ä¸»è¦å®ç°äº†Vulkanåç«¯ï¼Œæä¾›äº†å®Œæ•´çš„Vulkan APIå°è£…ï¼š

#### VulkanDevice æ¶æ„

```cpp
class VulkanDevice : public IRHIDevice {
private:
    // Vulkanæ ¸å¿ƒå¯¹è±¡
    VkInstance m_instance;
    VkPhysicalDevice m_physicalDevice;
    VkDevice m_device;
    
    // é˜Ÿåˆ—ç®¡ç†
    VkQueue m_graphicsQueue;
    VkQueue m_presentQueue;
    QueueFamily m_graphicsQueueFamily;
    QueueFamily m_presentQueueFamily;
    
    // äº¤æ¢é“¾
    VkSwapchainKHR m_swapchain;
    TArray<VkImage> m_swapchainImages;
    TArray<VkImageView> m_swapchainImageViews;
    
    // å‘½ä»¤å¤„ç†
    VkCommandPool m_commandPool;
    TUniquePtr<VulkanCommandList> m_immediateCommandList;
    
    // åŒæ­¥å¯¹è±¡
    TArray<VkSemaphore> m_imageAvailableSemaphores;
    TArray<VkSemaphore> m_renderFinishedSemaphores;
    TArray<VkFence> m_inFlightFences;
};
```

#### Vulkan åˆå§‹åŒ–æµç¨‹

```mermaid
graph TD
    A[createInstance] --> B[setupDebugMessenger]
    B --> C[createSurface]
    C --> D[selectPhysicalDevice]
    D --> E[createLogicalDevice]
    E --> F[createSwapchain]
    F --> G[createCommandPool]
    G --> H[createSyncObjects]
    H --> I[VulkanDevice Ready]
```

#### é˜Ÿåˆ—æ—ç®¡ç†

```cpp
struct QueueFamily {
    uint32 familyIndex = VK_QUEUE_FAMILY_IGNORED;
    uint32 queueCount = 0;
    VkQueueFlags flags = 0;
    bool supportsPresentToSurface = false;
};
```

### æœªæ¥å¹³å°æ”¯æŒ

å¼•æ“è®¾è®¡æ”¯æŒå¤šä¸ªå›¾å½¢APIåç«¯ï¼š

- **Direct3D 12**: ç°ä»£ä½çº§åˆ«APIï¼ŒWindowså¹³å°ä¸»è¦é€‰æ‹©
- **Direct3D 11**: ä¼ ç»Ÿé«˜çº§åˆ«APIï¼Œå‘åå…¼å®¹
- **OpenGL**: è·¨å¹³å°æ”¯æŒï¼ŒLinuxå’Œç§»åŠ¨å¹³å°
- **Metal**: Appleç”Ÿæ€ç³»ç»Ÿæ”¯æŒ

---

## ç±»å›¾å’Œå…³ç³»

### æ ¸å¿ƒç±»å±‚æ¬¡ç»“æ„

```mermaid
classDiagram
    class Engine {
        -TUniquePtr~IRHIDevice~ m_rhiDevice
        -bool m_initialized
        -bool m_shouldRun
        +initialize(RHICreateInfo) bool
        +shutdown() void
        +run() void
        +getRHIDevice() IRHIDevice*
    }
    
    class IRHIDevice {
        <<interface>>
        +getCapabilities() RHIDeviceCapabilities
        +createBuffer(BufferDesc) TSharedPtr~IRHIBuffer~
        +createTexture(TextureDesc) TSharedPtr~IRHITexture~
        +createCommandList() TSharedPtr~IRHICommandList~
        +waitForIdle() void
        +present() void
    }
    
    class VulkanDevice {
        -VkInstance m_instance
        -VkDevice m_device
        -VkPhysicalDevice m_physicalDevice
        -VkQueue m_graphicsQueue
        -VkSwapchainKHR m_swapchain
        +initialize(RHICreateInfo) bool
        +shutdown() void
    }
    
    class IRHICommandList {
        <<interface>>
        +begin() void
        +end() void
        +setPipelineState(IRHIPipelineState) void
        +setVertexBuffers(TSpan~IRHIBuffer~) void
        +draw(uint32, uint32) void
        +drawIndexed(uint32, uint32, int32) void
    }
    
    class VulkanCommandList {
        -VkCommandBuffer m_commandBuffer
        -VulkanDevice* m_device
        -bool m_isRecording
        +begin() void
        +end() void
    }
    
    class IRHIResource {
        <<interface>>
        +getResourceType() EResourceType
        +setDebugName(String) void
    }
    
    class IRHIBuffer {
        <<interface>>
        +getSize() uint32
        +getUsage() EResourceUsage
        +map() void*
        +unmap() void
    }
    
    class IRHITexture {
        <<interface>>
        +getWidth() uint32
        +getHeight() uint32
        +getFormat() EPixelFormat
        +getMipLevels() uint32
    }
    
    class RHIFactory {
        <<static>>
        +createDevice(RHICreateInfo) TUniquePtr~IRHIDevice~
        +getAvailableBackends() TArray~ERHIBackend~
        +selectBestBackend() ERHIBackend
    }
    
    Engine --> IRHIDevice : uses
    IRHIDevice <|.. VulkanDevice : implements
    IRHICommandList <|.. VulkanCommandList : implements
    IRHIResource <|-- IRHIBuffer : extends
    IRHIResource <|-- IRHITexture : extends
    RHIFactory ..> IRHIDevice : creates
    VulkanDevice --> VulkanCommandList : creates
    IRHIDevice --> IRHICommandList : creates
    IRHIDevice --> IRHIResource : creates
```

### èµ„æºç®¡ç†ç±»å›¾

```mermaid
classDiagram
    class IRHIResource {
        <<interface>>
        #String m_debugName
        +getResourceType() EResourceType
        +setDebugName(String) void
        +getDebugName() String
    }
    
    class IRHIBuffer {
        <<interface>>
        +getSize() uint32
        +getUsage() EResourceUsage
        +isCPUAccessible() bool
        +map() void*
        +unmap() void
    }
    
    class IRHITexture {
        <<interface>>
        +getWidth() uint32
        +getHeight() uint32
        +getDepth() uint32
        +getMipLevels() uint32
        +getArraySize() uint32
        +getFormat() EPixelFormat
        +getUsage() EResourceUsage
    }
    
    class VulkanBuffer {
        -VkBuffer m_buffer
        -VkDeviceMemory m_memory
        -VulkanDevice* m_device
        -BufferDesc m_desc
        -void* m_mappedData
        +map() void*
        +unmap() void
    }
    
    class VulkanTexture {
        -VkImage m_image
        -VkImageView m_imageView
        -VkDeviceMemory m_memory
        -VulkanDevice* m_device
        -TextureDesc m_desc
    }
    
    IRHIResource <|-- IRHIBuffer
    IRHIResource <|-- IRHITexture
    IRHIBuffer <|.. VulkanBuffer
    IRHITexture <|.. VulkanTexture
```

---

## æ•°æ®æµç¨‹

### å¼•æ“åˆå§‹åŒ–æµç¨‹

```mermaid
sequenceDiagram
    participant Main as main()
    participant Engine as Engine
    participant RHIFactory as RHIFactory
    participant VulkanDevice as VulkanDevice
    participant TriangleRenderer as TriangleRenderer
    
    Main->>Engine: new Engine()
    Main->>Engine: initialize(RHICreateInfo)
    Engine->>RHIFactory: createDevice(createInfo)
    RHIFactory->>VulkanDevice: new VulkanDevice()
    VulkanDevice->>VulkanDevice: initialize(createInfo)
    VulkanDevice-->>RHIFactory: device instance
    RHIFactory-->>Engine: TUniquePtr<IRHIDevice>
    Engine-->>Main: initialization result
    
    Main->>Engine: getRHIDevice()
    Engine-->>Main: IRHIDevice*
    
    Main->>TriangleRenderer: new TriangleRenderer()
    Main->>TriangleRenderer: initialize(device)
    TriangleRenderer->>VulkanDevice: createBuffer(vertexDesc)
    TriangleRenderer->>VulkanDevice: createVertexShader(bytecode)
    TriangleRenderer->>VulkanDevice: createPixelShader(bytecode)
    TriangleRenderer->>VulkanDevice: createPipelineState(pipelineDesc)
    TriangleRenderer-->>Main: initialization result
```

### æ¸²æŸ“å¾ªç¯æµç¨‹

```mermaid
sequenceDiagram
    participant Main as main()
    participant Engine as Engine
    participant Device as IRHIDevice
    participant CmdList as IRHICommandList
    participant TriangleRenderer as TriangleRenderer
    
    Main->>Device: getImmediateCommandList()
    Device-->>Main: IRHICommandList*
    
    Main->>CmdList: begin()
    Main->>TriangleRenderer: render(cmdList)
    
    TriangleRenderer->>CmdList: setPipelineState(m_pipelineState)
    TriangleRenderer->>CmdList: setVertexBuffers({m_vertexBuffer})
    TriangleRenderer->>CmdList: setViewport(viewport)
    TriangleRenderer->>CmdList: draw(vertexCount)
    
    Main->>CmdList: end()
    Main->>Device: present()
    Main->>Device: waitForIdle()
```

### èµ„æºåˆ›å»ºæµç¨‹

```mermaid
flowchart TD
    A[åº”ç”¨è¯·æ±‚åˆ›å»ºèµ„æº] --> B{æ£€æŸ¥èµ„æºç±»å‹}
    
    B -->|Buffer| C[åˆ›å»ºBufferDesc]
    B -->|Texture| D[åˆ›å»ºTextureDesc]
    B -->|Shader| E[åŠ è½½ç€è‰²å™¨å­—èŠ‚ç ]
    
    C --> F[IRHIDevice::createBuffer]
    D --> G[IRHIDevice::createTexture]
    E --> H[IRHIDevice::createVertexShader]
    
    F --> I[VulkanDeviceå®ç°]
    G --> I
    H --> I
    
    I --> J[åˆ†é…Vulkanèµ„æº]
    J --> K[åˆ†é…GPUå†…å­˜]
    K --> L[ç»‘å®šèµ„æºå’Œå†…å­˜]
    L --> M[è®¾ç½®è°ƒè¯•åç§°]
    M --> N[è¿”å›æ™ºèƒ½æŒ‡é’ˆåŒ…è£…çš„èµ„æº]
    
    N --> O[åº”ç”¨ä½¿ç”¨èµ„æº]
    O --> P[èµ„æºè¶…å‡ºä½œç”¨åŸŸ]
    P --> Q[æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾]
    Q --> R[è°ƒç”¨ææ„å‡½æ•°]
    R --> S[é‡Šæ”¾Vulkanèµ„æºå’Œå†…å­˜]
```

---

## è®¾è®¡æ¨¡å¼å’ŒåŸåˆ™

### 1. å·¥å‚æ¨¡å¼ (Factory Pattern)

**åº”ç”¨åœºæ™¯**: RHIè®¾å¤‡åˆ›å»º

```cpp
class RHIFactory {
public:
    static TUniquePtr<IRHIDevice> createDevice(const RHICreateInfo& createInfo) {
        switch(createInfo.preferredBackend) {
            case ERHIBackend::Vulkan:
                return MakeUnique<VulkanDevice>();
            case ERHIBackend::D3D12:
                // return MakeUnique<D3D12Device>();
            default:
                return nullptr;
        }
    }
};
```

**ä¼˜åŠ¿**:
- éšè—å…·ä½“å®ç°çš„åˆ›å»ºç»†èŠ‚
- æ”¯æŒè¿è¡Œæ—¶åç«¯é€‰æ‹©
- ä¾¿äºæ·»åŠ æ–°çš„å›¾å½¢APIåç«¯

### 2. æŠ½è±¡å·¥å‚æ¨¡å¼ (Abstract Factory)

**åº”ç”¨åœºæ™¯**: å¹³å°ç‰¹å®šçš„èµ„æºåˆ›å»º

æ¯ä¸ªå¹³å°çš„Deviceä½œä¸ºå·¥å‚ï¼Œåˆ›å»ºå¯¹åº”å¹³å°çš„èµ„æºï¼š
```cpp
// VulkanDevice ä½œä¸º Vulkan èµ„æºçš„æŠ½è±¡å·¥å‚
class VulkanDevice : public IRHIDevice {
public:
    TSharedPtr<IRHIBuffer> createBuffer(const BufferDesc& desc) override {
        return MakeShared<VulkanBuffer>(this, desc);
    }
    
    TSharedPtr<IRHITexture> createTexture(const TextureDesc& desc) override {
        return MakeShared<VulkanTexture>(this, desc);
    }
};
```

### 3. æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation)

**åº”ç”¨åœºæ™¯**: RHIæ¥å£è®¾è®¡

å°†å¤§å‹æ¥å£æ‹†åˆ†ä¸ºå¤šä¸ªä¸“ç”¨æ¥å£ï¼š
- `IRHIDevice` - è®¾å¤‡ç®¡ç†å’Œèµ„æºåˆ›å»º
- `IRHICommandList` - å‘½ä»¤è®°å½•å’Œæ‰§è¡Œ
- `IRHIResource` - èµ„æºåŸºç±»
- `IRHIBuffer` - ç¼“å†²åŒºç‰¹å®šæ“ä½œ
- `IRHITexture` - çº¹ç†ç‰¹å®šæ“ä½œ

### 4. RAII (Resource Acquisition Is Initialization)

**åº”ç”¨åœºæ™¯**: èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†

```cpp
class VulkanBuffer : public IRHIBuffer {
public:
    VulkanBuffer(VulkanDevice* device, const BufferDesc& desc) 
        : m_device(device), m_desc(desc) {
        // æ„é€ æ—¶åˆ›å»ºVulkanèµ„æº
        createVulkanBuffer();
    }
    
    ~VulkanBuffer() {
        // ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾Vulkanèµ„æº
        destroyVulkanBuffer();
    }
};
```

### 5. æ™ºèƒ½æŒ‡é’ˆç®¡ç† (Smart Pointer Management)

**åº”ç”¨åœºæ™¯**: è‡ªåŠ¨å†…å­˜ç®¡ç†

```cpp
// ç‹¬å æ‰€æœ‰æƒ
TUniquePtr<IRHIDevice> m_rhiDevice;

// å…±äº«æ‰€æœ‰æƒ
TSharedPtr<IRHIBuffer> m_vertexBuffer;
TSharedPtr<IRHIPipelineState> m_pipelineState;

// å¼±å¼•ç”¨ï¼ˆé¿å…å¾ªç¯å¼•ç”¨ï¼‰
TWeakPtr<IRHIDevice> m_parentDevice;
```

### 6. å‘½ä»¤æ¨¡å¼ (Command Pattern)

**åº”ç”¨åœºæ™¯**: æ¸²æŸ“å‘½ä»¤è®°å½•

```cpp
class IRHICommandList {
public:
    // æ¯ä¸ªæ–¹æ³•éƒ½æ˜¯ä¸€ä¸ªå‘½ä»¤ï¼Œå»¶è¿Ÿæ‰§è¡Œ
    virtual void draw(uint32 vertexCount, uint32 startVertexLocation = 0) = 0;
    virtual void drawIndexed(uint32 indexCount, uint32 startIndexLocation = 0) = 0;
    virtual void setPipelineState(TSharedPtr<IRHIPipelineState> pipelineState) = 0;
};
```

### 7. æ¨¡æ¿å…ƒç¼–ç¨‹å’Œç±»å‹å®‰å…¨

**åº”ç”¨åœºæ™¯**: ç±»å‹å®‰å…¨çš„æ™ºèƒ½æŒ‡é’ˆåˆ«å

```cpp
template<typename T>
using TSharedPtr = std::shared_ptr<T>;

template<typename T, typename... Args>
constexpr TSharedPtr<T> MakeShared(Args&&... args) {
    return std::make_shared<T>(std::forward<Args>(args)...);
}
```

---

## å†…å­˜ç®¡ç†ç­–ç•¥

### 1. æ™ºèƒ½æŒ‡é’ˆç­–ç•¥

MonsterEngineé‡‡ç”¨ç°ä»£C++çš„æ™ºèƒ½æŒ‡é’ˆè¿›è¡Œå†…å­˜ç®¡ç†ï¼š

#### æ‰€æœ‰æƒæ¨¡å‹
```cpp
// ç‹¬å æ‰€æœ‰æƒ - å¼•æ“æ ¸å¿ƒç»„ä»¶
TUniquePtr<RHI::IRHIDevice> m_rhiDevice;     // Engineæ‹¥æœ‰è®¾å¤‡

// å…±äº«æ‰€æœ‰æƒ - æ¸²æŸ“èµ„æº
TSharedPtr<IRHIBuffer> m_vertexBuffer;        // å¯è¢«å¤šä¸ªå¯¹è±¡å…±äº«
TSharedPtr<IRHIPipelineState> m_pipelineState; // ç®¡é“çŠ¶æ€å¯é‡ç”¨

// å¼±å¼•ç”¨ - é¿å…å¾ªç¯å¼•ç”¨
TWeakPtr<IRHIDevice> m_parentDevice;          // å­å¯¹è±¡å¼•ç”¨çˆ¶è®¾å¤‡
```

#### èµ„æºåˆ›å»ºæ¨¡å¼
```cpp
// ä½¿ç”¨å·¥å‚å‡½æ•°åˆ›å»ºèµ„æºï¼Œè¿”å›æ™ºèƒ½æŒ‡é’ˆ
auto buffer = device->createBuffer(bufferDesc);
auto texture = device->createTexture(textureDesc);
auto pipeline = device->createPipelineState(pipelineDesc);

// è‡ªåŠ¨ææ„ï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾
```

### 2. GPUå†…å­˜ç®¡ç†

#### Vulkanå†…å­˜åˆ†é…ç­–ç•¥
```cpp
class VulkanBuffer : public IRHIBuffer {
private:
    VkBuffer m_buffer;
    VkDeviceMemory m_memory;
    
    // å†…å­˜ç±»å‹é€‰æ‹©
    uint32 findMemoryType(uint32 typeFilter, VkMemoryPropertyFlags properties);
    
    // å†…å­˜æ˜ å°„çŠ¶æ€
    void* m_mappedData = nullptr;
    bool m_isPersistentlyMapped = false;
};
```

#### å†…å­˜æ± å’Œåˆ†é…å™¨
```cpp
// æœªæ¥æ‰©å±•ï¼šå†…å­˜åˆ†é…å™¨
class GPUMemoryAllocator {
public:
    struct Allocation {
        VkDeviceMemory memory;
        VkDeviceSize offset;
        VkDeviceSize size;
    };
    
    Allocation allocate(VkDeviceSize size, VkDeviceSize alignment, uint32 memoryType);
    void deallocate(const Allocation& allocation);
};
```

### 3. CPUå†…å­˜ä¼˜åŒ–

#### å¯¹è±¡æ± æ¨¡å¼
```cpp
template<typename T>
class ObjectPool {
private:
    std::vector<std::unique_ptr<T>> m_pool;
    std::queue<T*> m_available;
    
public:
    T* acquire() {
        if (m_available.empty()) {
            m_pool.emplace_back(std::make_unique<T>());
            return m_pool.back().get();
        }
        T* obj = m_available.front();
        m_available.pop();
        return obj;
    }
    
    void release(T* obj) {
        obj->reset();  // é‡ç½®å¯¹è±¡çŠ¶æ€
        m_available.push(obj);
    }
};
```

#### æ ˆåˆ†é…å™¨
```cpp
class StackAllocator {
private:
    uint8* m_data;
    size_t m_size;
    size_t m_offset;
    
public:
    template<typename T>
    T* allocate(size_t count = 1) {
        size_t size = sizeof(T) * count;
        if (m_offset + size > m_size) return nullptr;
        
        T* ptr = reinterpret_cast<T*>(m_data + m_offset);
        m_offset += size;
        return ptr;
    }
    
    void reset() { m_offset = 0; }  // é‡ç½®æ•´ä¸ªåˆ†é…å™¨
};
```

---

## æ€§èƒ½è€ƒè™‘

### 1. GPUæ€§èƒ½ä¼˜åŒ–

#### æ‰¹å¤„ç†å’Œå®ä¾‹åŒ–
```cpp
class BatchRenderer {
public:
    struct DrawCall {
        TSharedPtr<IRHIPipelineState> pipelineState;
        TSharedPtr<IRHIBuffer> vertexBuffer;
        TSharedPtr<IRHIBuffer> indexBuffer;
        uint32 indexCount;
    };
    
    void addDrawCall(const DrawCall& drawCall);
    void flush(IRHICommandList* cmdList);  // æ‰¹é‡æäº¤ç»˜åˆ¶è°ƒç”¨
};
```

#### GPUé©±åŠ¨æ¸²æŸ“
```cpp
// æœªæ¥æ‰©å±•ï¼šé—´æ¥ç»˜åˆ¶
struct IndirectDrawCommand {
    uint32 indexCount;
    uint32 instanceCount;
    uint32 firstIndex;
    uint32 vertexOffset;
    uint32 firstInstance;
};

void IRHICommandList::drawIndexedIndirect(
    TSharedPtr<IRHIBuffer> commandBuffer,
    uint32 drawCount
);
```

#### èµ„æºçŠ¶æ€è·Ÿè¸ª
```cpp
class ResourceStateTracker {
private:
    struct ResourceState {
        TWeakPtr<IRHIResource> resource;
        EResourceUsage currentState;
        EResourceUsage pendingState;
    };
    
    TMap<IRHIResource*, ResourceState> m_states;
    
public:
    void transitionResource(TSharedPtr<IRHIResource> resource, 
                          EResourceUsage newState);
    void flushBarriers(IRHICommandList* cmdList);
};
```

### 2. CPUæ€§èƒ½ä¼˜åŒ–

#### å¤šçº¿ç¨‹å‘½ä»¤åˆ—è¡¨ç”Ÿæˆ
```cpp
class ParallelCommandListManager {
private:
    TArray<TSharedPtr<IRHICommandList>> m_commandLists;
    std::atomic<uint32> m_currentIndex{0};
    
public:
    IRHICommandList* acquireCommandList() {
        uint32 index = m_currentIndex.fetch_add(1) % m_commandLists.size();
        return m_commandLists[index].get();
    }
    
    void submitAll(IRHIDevice* device) {
        device->executeCommandLists(m_commandLists);
    }
};
```

#### æ— é”æ•°æ®ç»“æ„
```cpp
template<typename T>
class LockFreeRingBuffer {
private:
    std::atomic<size_t> m_head{0};
    std::atomic<size_t> m_tail{0};
    TArray<T> m_buffer;
    
public:
    bool enqueue(const T& item);
    bool dequeue(T& item);
};
```

### 3. å†…å­˜å¸¦å®½ä¼˜åŒ–

#### æ•°æ®ç»“æ„ä¼˜åŒ–
```cpp
// SOA (Structure of Arrays) å¸ƒå±€ä¼˜åŒ–ç¼“å­˜å‘½ä¸­ç‡
class ParticleSystemSOA {
private:
    TArray<float32> m_positionsX;
    TArray<float32> m_positionsY; 
    TArray<float32> m_positionsZ;
    TArray<float32> m_velocitiesX;
    TArray<float32> m_velocitiesY;
    TArray<float32> m_velocitiesZ;
    
public:
    void updatePositions(float32 deltaTime);  // å‘é‡åŒ–å‹å¥½
};
```

---

## æ‰©å±•æ€§è®¾è®¡

### 1. æ–°å›¾å½¢APIåç«¯æ‰©å±•

#### æ·»åŠ æ–°åç«¯çš„æ­¥éª¤

1. **åˆ›å»ºå¹³å°ç›®å½•ç»“æ„**:
```cpp
Platform/
â””â”€â”€ D3D12/
    â”œâ”€â”€ D3D12RHI.h
    â”œâ”€â”€ D3D12Device.h
    â”œâ”€â”€ D3D12CommandList.h
    â”œâ”€â”€ D3D12Buffer.h
    â””â”€â”€ D3D12Texture.h
```

2. **å®ç°RHIæ¥å£**:
```cpp
class D3D12Device : public IRHIDevice {
private:
    ComPtr<ID3D12Device> m_device;
    ComPtr<ID3D12CommandQueue> m_commandQueue;
    ComPtr<IDXGISwapChain3> m_swapChain;
    
public:
    // å®ç°æ‰€æœ‰IRHIDeviceæ¥å£
    TSharedPtr<IRHIBuffer> createBuffer(const BufferDesc& desc) override;
    TSharedPtr<IRHITexture> createTexture(const TextureDesc& desc) override;
    // ...
};
```

3. **æ›´æ–°RHIå·¥å‚**:
```cpp
TUniquePtr<IRHIDevice> RHIFactory::createDevice(const RHICreateInfo& createInfo) {
    switch(createInfo.preferredBackend) {
        case ERHIBackend::Vulkan:
            return MakeUnique<VulkanDevice>();
        case ERHIBackend::D3D12:
            return MakeUnique<D3D12Device>();  // æ–°å¢
        case ERHIBackend::D3D11:
            return MakeUnique<D3D11Device>();  // æ–°å¢
        default:
            return nullptr;
    }
}
```

### 2. æ¸²æŸ“åŠŸèƒ½æ‰©å±•

#### æ·»åŠ æ–°çš„æ¸²æŸ“Pass
```cpp
class RenderPass {
public:
    virtual ~RenderPass() = default;
    virtual void execute(IRHICommandList* cmdList, const RenderContext& context) = 0;
    virtual String getName() const = 0;
};

class ShadowMapPass : public RenderPass {
public:
    void execute(IRHICommandList* cmdList, const RenderContext& context) override {
        // å®ç°é˜´å½±è´´å›¾æ¸²æŸ“é€»è¾‘
    }
    String getName() const override { return "ShadowMap"; }
};

class PostProcessPass : public RenderPass {
public:
    void execute(IRHICommandList* cmdList, const RenderContext& context) override {
        // å®ç°åå¤„ç†æ•ˆæœ
    }
    String getName() const override { return "PostProcess"; }
};
```

#### æ¸²æŸ“ç®¡é“æ‰©å±•
```cpp
class RenderPipeline {
private:
    TArray<TUniquePtr<RenderPass>> m_passes;
    
public:
    void addPass(TUniquePtr<RenderPass> pass) {
        m_passes.push_back(std::move(pass));
    }
    
    void execute(IRHICommandList* cmdList, const RenderContext& context) {
        for (auto& pass : m_passes) {
            pass->execute(cmdList, context);
        }
    }
};
```

### 3. å¹³å°ç‰¹æ€§æ”¯æŒ

#### å¹³å°æ£€æµ‹å’ŒåŠŸèƒ½æŸ¥è¯¢
```cpp
class PlatformCapabilities {
public:
    static bool supportsRayTracing();
    static bool supportsVariableRateShading();
    static bool supportsMeshShaders();
    static bool supportsComputeShaders();
    
    static TArray<ERHIBackend> getSupportedBackends();
    static uint64 getTotalSystemMemory();
    static uint64 getTotalVideoMemory();
};
```

#### å¹³å°ç‰¹å®šä¼˜åŒ–
```cpp
#if PLATFORM_WINDOWS
    // Windowsç‰¹å®šä¼˜åŒ–
    #include <d3d12.h>
    #include <dxgi1_6.h>
#elif PLATFORM_LINUX  
    // Linuxç‰¹å®šä¼˜åŒ–
    #include <X11/Xlib.h>
    #include <vulkan/vulkan_xlib.h>
#elif PLATFORM_ANDROID
    // Androidç‰¹å®šä¼˜åŒ–
    #include <android/native_window.h>
    #include <vulkan/vulkan_android.h>
#endif
```

### 4. ç€è‰²å™¨ç³»ç»Ÿæ‰©å±•

#### è·¨å¹³å°ç€è‰²å™¨ç¼–è¯‘
```cpp
class ShaderCompiler {
public:
    struct CompileOptions {
        EShaderStage stage;
        String entryPoint = "main";
        String targetProfile;  // "vs_5_0", "ps_5_0", etc.
        TMap<String, String> defines;
        bool generateDebugInfo = false;
    };
    
    virtual TArray<uint8> compileFromSource(
        const String& source, 
        const CompileOptions& options
    ) = 0;
    
    virtual TArray<uint8> compileFromFile(
        const String& filePath,
        const CompileOptions& options  
    ) = 0;
};

class HLSLCompiler : public ShaderCompiler { /* å®ç°HLSLç¼–è¯‘ */ };
class GLSLCompiler : public ShaderCompiler { /* å®ç°GLSLç¼–è¯‘ */ };
```

#### ç€è‰²å™¨åå°„å’Œç»‘å®š
```cpp
class ShaderReflection {
public:
    struct ConstantBuffer {
        String name;
        uint32 bindPoint;
        uint32 size;
        TArray<ShaderVariable> variables;
    };
    
    struct ShaderResource {
        String name;
        uint32 bindPoint;
        EResourceType type;
    };
    
    TArray<ConstantBuffer> getConstantBuffers() const;
    TArray<ShaderResource> getShaderResources() const;
};
```

---

## æ€»ç»“

MonsterEngineé‡‡ç”¨äº†ç°ä»£åŒ–çš„æ¶æ„è®¾è®¡ï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

### æ¶æ„ä¼˜åŠ¿

1. **åˆ†å±‚æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚è®¾è®¡ä½¿å¾—å„ä¸ªæ¨¡å—èŒè´£æ˜ç¡®ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **è·¨å¹³å°æŠ½è±¡**: RHIå±‚æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œå±è”½ä¸åŒå›¾å½¢APIçš„å·®å¼‚
3. **ç°ä»£C++**: å……åˆ†åˆ©ç”¨C++20ç‰¹æ€§ï¼Œæä¾›ç±»å‹å®‰å…¨å’Œé«˜æ€§èƒ½
4. **æ¨¡å—åŒ–è®¾è®¡**: æ¯ä¸ªæ¨¡å—éƒ½å¯ä»¥ç‹¬ç«‹å¼€å‘å’Œæµ‹è¯•
5. **æ‰©å±•æ€§å¼º**: æ˜“äºæ·»åŠ æ–°çš„å›¾å½¢APIåç«¯å’Œæ¸²æŸ“åŠŸèƒ½

### è®¾è®¡ç‰¹ç‚¹

- **RAIIèµ„æºç®¡ç†**: è‡ªåŠ¨åŒ–çš„èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†
- **æ™ºèƒ½æŒ‡é’ˆ**: é¿å…å†…å­˜æ³„æ¼å’Œæ‚¬ç©ºæŒ‡é’ˆ
- **å·¥å‚æ¨¡å¼**: æ”¯æŒè¿è¡Œæ—¶åç«¯é€‰æ‹©
- **æ¥å£éš”ç¦»**: ä¸“ç”¨æ¥å£æé«˜ä»£ç å¯ç»´æŠ¤æ€§
- **æ€§èƒ½ä¼˜åŒ–**: GPUé©±åŠ¨æ¸²æŸ“å’Œå¤šçº¿ç¨‹æ”¯æŒ

### æœªæ¥å‘å±•

MonsterEngineä¸ºæœªæ¥çš„æ‰©å±•æä¾›äº†è‰¯å¥½çš„åŸºç¡€ï¼š

- æ”¯æŒæ›´å¤šå›¾å½¢API (D3D12, D3D11, OpenGL, Metal)
- é«˜çº§æ¸²æŸ“åŠŸèƒ½ (PBR, å…‰çº¿è¿½è¸ª, è®¡ç®—ç€è‰²å™¨)
- è·¨å¹³å°æ”¯æŒ (Linux, Android, iOS, macOS)
- ç°ä»£æ¸²æŸ“æŠ€æœ¯ (ç½‘æ ¼ç€è‰²å™¨, å¯å˜é€Ÿç‡ç€è‰²)
- æ€§èƒ½ä¼˜åŒ– (GPUé©±åŠ¨æ¸²æŸ“, å¤šçº¿ç¨‹å‘½ä»¤ç”Ÿæˆ)

è¿™ä¸ªå¼•æ“æ¶æ„ä¸ºç°ä»£æ¸¸æˆå’Œå®æ—¶æ¸²æŸ“åº”ç”¨æä¾›äº†ä¸€ä¸ªåšå®çš„æŠ€æœ¯åŸºç¡€ï¼ŒåŒæ—¶ä¿æŒäº†è¶³å¤Ÿçš„çµæ´»æ€§æ¥é€‚åº”æœªæ¥çš„æŠ€æœ¯å‘å±•ã€‚

---

## æœ€æ–°å¼€å‘è¿›å±•

### VulkanDevice å®Œæ•´å®ç° (2025å¹´9æœˆ21æ—¥)

æœ¬æ¬¡å¼€å‘å®Œæˆäº† VulkanDevice.cpp ä¸­æ‰€æœ‰æ ¸å¿ƒå‡½æ•°çš„å®Œæ•´å®ç°ï¼Œæ ‡å¿—ç€ MonsterEngine çš„ Vulkan åç«¯ä»æ¡†æ¶è®¾è®¡è½¬å‘å®é™…å¯ç”¨çš„å®ç°ã€‚

#### ğŸš€ ä¸»è¦å®ç°å†…å®¹

##### 1. Vulkan å®ä¾‹ç®¡ç†
```cpp
// Vulkan å®ä¾‹åˆ›å»ºå’Œé…ç½®
bool VulkanDevice::createInstance(const RHICreateInfo& createInfo) {
    // âœ… å®Œæ•´çš„ Vulkan å®ä¾‹åˆ›å»ºæµç¨‹
    // âœ… éªŒè¯å±‚æ”¯æŒæ£€æŸ¥
    // âœ… æ‰©å±•ç®¡ç† (å¹³å°ç‰¹å®š)
    // âœ… è°ƒè¯•ä¿¡æ¯é…ç½®
}
```

**æ ¸å¿ƒç‰¹æ€§**:
- è·¨å¹³å°æ‰©å±•æ”¯æŒ (Windows/Linux)
- éªŒè¯å±‚åŠ¨æ€å¯ç”¨/ç¦ç”¨
- å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- è°ƒè¯•æ¶ˆæ¯å™¨è‡ªåŠ¨é…ç½®

##### 2. ç‰©ç†è®¾å¤‡é€‰æ‹©ç®—æ³•
```cpp
// æ™ºèƒ½è®¾å¤‡é€‰æ‹©å’Œè¯„ä¼°
bool VulkanDevice::selectPhysicalDevice() {
    // âœ… å¤š GPU ç¯å¢ƒä¸‹çš„è®¾å¤‡æšä¸¾
    // âœ… è®¾å¤‡é€‚ç”¨æ€§è¯„ä¼°ç®—æ³•
    // âœ… é˜Ÿåˆ—æ—æ”¯æŒæ£€æŸ¥
    // âœ… æ‰©å±•å…¼å®¹æ€§éªŒè¯
}
```

**é€‰æ‹©æ ‡å‡†**:
- é˜Ÿåˆ—æ—æ”¯æŒ (å›¾å½¢ã€å‘ˆç°)
- å¿…éœ€æ‰©å±•æ”¯æŒ
- äº¤æ¢é“¾å…¼å®¹æ€§
- è®¾å¤‡ç‰¹æ€§æ”¯æŒ

##### 3. é€»è¾‘è®¾å¤‡å’Œé˜Ÿåˆ—ç®¡ç†
```cpp
// é€»è¾‘è®¾å¤‡åˆ›å»ºå’Œé˜Ÿåˆ—è·å–
bool VulkanDevice::createLogicalDevice() {
    // âœ… é˜Ÿåˆ—æ—å‘ç°å’Œé…ç½®
    // âœ… è®¾å¤‡ç‰¹æ€§å¯ç”¨
    // âœ… æ‰©å±•æ¿€æ´»
    // âœ… é˜Ÿåˆ—å¥æŸ„è·å–
}
```

**é˜Ÿåˆ—æ¶æ„**:
- å›¾å½¢é˜Ÿåˆ—: ä¸»è¦æ¸²æŸ“å‘½ä»¤
- å‘ˆç°é˜Ÿåˆ—: äº¤æ¢é“¾å‘ˆç°
- ç»Ÿä¸€æˆ–åˆ†ç¦»é˜Ÿåˆ—æ”¯æŒ

##### 4. äº¤æ¢é“¾å®Œæ•´å®ç°
```cpp
// é«˜çº§äº¤æ¢é“¾ç®¡ç†
bool VulkanDevice::createSwapchain(const RHICreateInfo& createInfo) {
    // âœ… è¡¨é¢èƒ½åŠ›æŸ¥è¯¢
    // âœ… æ ¼å¼å’Œå‘ˆç°æ¨¡å¼é€‰æ‹©
    // âœ… å›¾åƒè§†å›¾åˆ›å»º
    // âœ… å¤šé‡ç¼“å†²æ”¯æŒ
}
```

**äº¤æ¢é“¾ç‰¹æ€§**:
- è‡ªé€‚åº”æ ¼å¼é€‰æ‹© (ä¼˜å…ˆ SRGB)
- å‘ˆç°æ¨¡å¼ä¼˜åŒ– (Mailbox > FIFO)
- åŠ¨æ€åˆ†è¾¨ç‡è°ƒæ•´
- å›¾åƒè§†å›¾è‡ªåŠ¨ç®¡ç†

##### 5. å‘½ä»¤ç³»ç»Ÿæ¶æ„
```cpp
// å‘½ä»¤æ± å’Œå‘½ä»¤åˆ—è¡¨ç®¡ç†
bool VulkanDevice::createCommandPool() {
    // âœ… çº¿ç¨‹å®‰å…¨çš„å‘½ä»¤æ± 
    // âœ… å³æ—¶å‘½ä»¤åˆ—è¡¨åˆ›å»º
    // âœ… å‘½ä»¤ç¼“å†²åŒºé‡ç½®æ”¯æŒ
}

void VulkanDevice::executeCommandLists(TSpan<TSharedPtr<IRHICommandList>> commandLists) {
    // âœ… æ‰¹é‡å‘½ä»¤æäº¤
    // âœ… ç±»å‹å®‰å…¨çš„è½¬æ¢
    // âœ… é˜Ÿåˆ—åŒæ­¥
}
```

##### 6. åŒæ­¥åŸè¯­ç³»ç»Ÿ
```cpp
// å®Œæ•´çš„ GPU-CPU åŒæ­¥
bool VulkanDevice::createSyncObjects() {
    // âœ… ä¿¡å·é‡åˆ›å»º (å›¾åƒå¯ç”¨/æ¸²æŸ“å®Œæˆ)
    // âœ… æ …æ ç®¡ç† (å¸§åŒæ­¥)
    // âœ… å¤šå¸§å¹¶è¡Œæ”¯æŒ
}
```

**åŒæ­¥ç­–ç•¥**:
- åŒé‡ç¼“å†²/ä¸‰é‡ç¼“å†²æ”¯æŒ
- å¸§é—´ä¾èµ–ç®¡ç†
- GPU-CPU åŒæ­¥ä¼˜åŒ–

##### 7. å‘ˆç°å¾ªç¯å®ç°
```cpp
// å®Œæ•´çš„å‘ˆç°ç®¡é“
void VulkanDevice::present() {
    // âœ… å¸§åŒæ­¥ç­‰å¾…
    // âœ… äº¤æ¢é“¾å›¾åƒè·å–
    // âœ… å‘ˆç°é˜Ÿåˆ—æäº¤
    // âœ… é”™è¯¯å¤„ç†å’Œæ¢å¤
}
```

#### ğŸ”§ è¾…åŠ©ç³»ç»Ÿå®ç°

##### è®¾å¤‡èƒ½åŠ›æŸ¥è¯¢ç³»ç»Ÿ
```cpp
void VulkanDevice::queryCapabilities() {
    // âœ… å®æ—¶è®¾å¤‡ä¿¡æ¯è·å–
    // âœ… ä¾›åº”å•†è¯†åˆ« (NVIDIA/AMD/Intel/ARM/Qualcomm)
    // âœ… å†…å­˜ç»Ÿè®¡å’Œåˆ†ç±»
    // âœ… ç‰¹æ€§æ”¯æŒæ£€æµ‹
    // âœ… é™åˆ¶å‚æ•°æ˜ å°„
}
```

**èƒ½åŠ›æ£€æµ‹è¦†ç›–**:
- çº¹ç†å°ºå¯¸é™åˆ¶
- æ¸²æŸ“ç›®æ ‡æ•°é‡
- å‡ ä½•ç€è‰²å™¨æ”¯æŒ
- ç»†åˆ†ç€è‰²å™¨æ”¯æŒ
- è®¡ç®—ç€è‰²å™¨æ”¯æŒ
- å¤šé‡ç»˜åˆ¶æ”¯æŒ
- æ—¶é—´æˆ³æŸ¥è¯¢æ”¯æŒ

##### éªŒè¯å’Œè°ƒè¯•ç³»ç»Ÿ
```cpp
// å¼€å‘å‹å¥½çš„è°ƒè¯•æ”¯æŒ
bool VulkanDevice::checkValidationLayerSupport() {
    // âœ… è¿è¡Œæ—¶éªŒè¯å±‚æ£€æŸ¥
    // âœ… å±‚å¯ç”¨æ€§éªŒè¯
}

bool VulkanDevice::setupDebugMessenger() {
    // âœ… è°ƒè¯•æ¶ˆæ¯å›è°ƒè®¾ç½®
    // âœ… æ¶ˆæ¯ä¸¥é‡æ€§è¿‡æ»¤
    // âœ… è‡ªå®šä¹‰æ—¥å¿—é›†æˆ
}
```

#### ğŸ“Š å®ç°ç»Ÿè®¡

| åŠŸèƒ½æ¨¡å— | å®ç°çŠ¶æ€ | ä»£ç è¡Œæ•° | å®Œæˆåº¦ |
|---------|---------|---------|-------|
| å®ä¾‹ç®¡ç† | âœ… å®Œæˆ | ~80 è¡Œ | 100% |
| è®¾å¤‡é€‰æ‹© | âœ… å®Œæˆ | ~60 è¡Œ | 100% |
| é€»è¾‘è®¾å¤‡ | âœ… å®Œæˆ | ~90 è¡Œ | 100% |
| äº¤æ¢é“¾ | âœ… å®Œæˆ | ~120 è¡Œ | 100% |
| å‘½ä»¤ç³»ç»Ÿ | âœ… å®Œæˆ | ~50 è¡Œ | 90% |
| åŒæ­¥å¯¹è±¡ | âœ… å®Œæˆ | ~40 è¡Œ | 100% |
| å‘ˆç°å¾ªç¯ | âœ… å®Œæˆ | ~60 è¡Œ | 95% |
| èƒ½åŠ›æŸ¥è¯¢ | âœ… å®Œæˆ | ~70 è¡Œ | 100% |
| è°ƒè¯•æ”¯æŒ | âœ… å®Œæˆ | ~40 è¡Œ | 100% |
| **æ€»è®¡** | **9/9 å®Œæˆ** | **~610 è¡Œ** | **98%** |

#### ğŸ¯ æ¶æ„ä¼˜åŠ¿

##### 1. é”™è¯¯å¤„ç†ç­–ç•¥
- **åˆ†å±‚é”™è¯¯å¤„ç†**: æ¯ä¸ªå‡½æ•°éƒ½æœ‰å®Œæ•´çš„é”™è¯¯æ£€æŸ¥
- **graceful degradation**: ç¼ºå°‘åŠŸèƒ½æ—¶ä¼˜é›…é™çº§
- **è¯¦ç»†æ—¥å¿—è®°å½•**: æ‰€æœ‰å…³é”®æ“ä½œéƒ½æœ‰æ—¥å¿—è·Ÿè¸ª

##### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–
- **RAII åŸåˆ™**: æ‰€æœ‰ Vulkan å¯¹è±¡è‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
- **æ™ºèƒ½æŒ‡é’ˆ**: é¿å…å†…å­˜æ³„æ¼å’Œæ‚¬ç©ºæŒ‡é’ˆ
- **èµ„æºè·Ÿè¸ª**: å®Œæ•´çš„åˆ›å»º/é”€æ¯é…å¯¹

##### 3. æ€§èƒ½è€ƒè™‘
- **æ‰¹é‡æ“ä½œ**: å‘½ä»¤åˆ—è¡¨æ‰¹é‡æäº¤å‡å°‘è°ƒç”¨å¼€é”€
- **å¹¶è¡Œæ¸²æŸ“**: å¤šå¸§å¹¶è¡Œæ”¯æŒæé«˜ GPU åˆ©ç”¨ç‡
- **ä¼˜åŒ–é€‰æ‹©**: è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çš„å‘ˆç°æ¨¡å¼å’Œæ ¼å¼

#### ğŸ”® åç»­å¼€å‘è®¡åˆ’

##### çŸ­æœŸç›®æ ‡ (1-2å‘¨)
- **ç®¡é“çŠ¶æ€å®ç°**: å®Œæˆ `createPipelineState()` åŠŸèƒ½
- **æ¸²æŸ“é€šé“**: å®ç° Vulkan æ¸²æŸ“é€šé“ç®¡ç†
- **æè¿°ç¬¦é›†**: å®ç°èµ„æºç»‘å®šç³»ç»Ÿ

##### ä¸­æœŸç›®æ ‡ (1ä¸ªæœˆ)
- **ç€è‰²å™¨ç¼–è¯‘**: é›†æˆ HLSL->SPIR-V ç¼–è¯‘ç®¡é“
- **èµ„æºç®¡ç†**: å®Œå–„ç¼“å†²åŒºå’Œçº¹ç†å®ç°
- **çª—å£ç³»ç»Ÿ**: é›†æˆå®é™…çš„çª—å£åˆ›å»º

##### é•¿æœŸç›®æ ‡ (3ä¸ªæœˆ)
- **å¤šçº¿ç¨‹ä¼˜åŒ–**: å¹¶è¡Œå‘½ä»¤åˆ—è¡¨ç”Ÿæˆ
- **é«˜çº§ç‰¹æ€§**: è®¡ç®—ç€è‰²å™¨ã€å‡ ä½•ç€è‰²å™¨æ”¯æŒ
- **å¹³å°æ‰©å±•**: Linux å’Œ Android æ”¯æŒ

#### ğŸ’¡ æŠ€æœ¯äº®ç‚¹

1. **ç°ä»£ C++ è®¾è®¡**
   - å¹¿æ³›ä½¿ç”¨ C++20 ç‰¹æ€§
   - RAII å’Œæ™ºèƒ½æŒ‡é’ˆ
   - å¼ºç±»å‹å®‰å…¨

2. **è·¨å¹³å°æ¶æ„**
   - å¹³å°ç‰¹å®šä»£ç éš”ç¦»
   - ç»Ÿä¸€çš„æ¥å£æŠ½è±¡
   - ç¼–è¯‘æ—¶å¹³å°æ£€æµ‹

3. **è°ƒè¯•å‹å¥½**
   - è¯¦ç»†çš„æ—¥å¿—è¾“å‡º
   - éªŒè¯å±‚é›†æˆ
   - é”™è¯¯è¿½è¸ªæ”¯æŒ

4. **å¯ç»´æŠ¤æ€§**
   - æ¸…æ™°çš„å‡½æ•°åˆ†ç¦»
   - å®Œæ•´çš„æ–‡æ¡£æ³¨é‡Š
   - ä¸€è‡´çš„é”™è¯¯å¤„ç†

è¿™æ¬¡å®ç°æ ‡å¿—ç€ MonsterEngine ä»æ¦‚å¿µåŸå‹è½¬å‘å®é™…å¯ç”¨çš„æ¸²æŸ“å¼•æ“ï¼Œä¸ºåç»­çš„é«˜çº§æ¸²æŸ“åŠŸèƒ½å¼€å‘å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚

---

## VulkanPipelineState å®Œæ•´å®ç° (2025å¹´9æœˆ21æ—¥)

æœ¬æ¬¡å¼€å‘å®Œæˆäº† VulkanPipelineState çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬å›¾å½¢ç®¡é“åˆ›å»ºã€ç®¡é“ç¼“å­˜æœºåˆ¶ã€ç€è‰²å™¨åå°„ç³»ç»Ÿå’ŒåŸºç¡€ä¸‰è§’å½¢æ¸²æŸ“æ¼”ç¤ºï¼Œæ ‡å¿—ç€ MonsterEngine çš„æ¸²æŸ“ç®¡çº¿ä»æ¡†æ¶è®¾è®¡è½¬å‘å®é™…å¯ç”¨çš„å®ç°ã€‚

### ğŸš€ ä¸»è¦å®ç°å†…å®¹

#### 1. VulkanPipelineState æ ¸å¿ƒç±»
```cpp
class VulkanPipelineState : public IRHIPipelineState {
private:
    VulkanDevice* m_device;
    bool m_isValid;
    
    // Vulkan æ ¸å¿ƒå¯¹è±¡
    VkPipeline m_pipeline;
    VkPipelineLayout m_pipelineLayout;
    VkRenderPass m_renderPass;
    
    // ç€è‰²å™¨æ¨¡å—ç®¡ç†
    TArray<VkShaderModule> m_shaderModules;
    TArray<VkPipelineShaderStageCreateInfo> m_shaderStages;
    
    // åå°„æ•°æ®
    TArray<ShaderReflectionData> m_reflectionData;
    
    // ç¼“å­˜æ¡ç›®
    PipelineCacheEntry m_cacheEntry;
};
```

**æ ¸å¿ƒç‰¹æ€§**:
- å®Œæ•´çš„ Vulkan å›¾å½¢ç®¡é“åˆ›å»ºæµç¨‹
- ç€è‰²å™¨æ¨¡å—ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ¸²æŸ“é€šé“å’Œç®¡é“å¸ƒå±€ç®¡ç†
- ç€è‰²å™¨åå°„æ•°æ®å­˜å‚¨

#### 2. å›¾å½¢ç®¡é“åˆ›å»ºæµç¨‹
```cpp
bool VulkanPipelineState::createGraphicsPipeline() {
    // âœ… é¡¶ç‚¹è¾“å…¥çŠ¶æ€é…ç½®
    // âœ… è¾“å…¥è£…é…çŠ¶æ€è®¾ç½®
    // âœ… è§†å£å’Œè£å‰ªçŸ©å½¢é…ç½®
    // âœ… å…‰æ …åŒ–çŠ¶æ€è®¾ç½®
    // âœ… å¤šé‡é‡‡æ ·çŠ¶æ€é…ç½®
    // âœ… é¢œè‰²æ··åˆçŠ¶æ€è®¾ç½®
    // âœ… æ·±åº¦æ¨¡æ¿çŠ¶æ€é…ç½®
    // âœ… åŠ¨æ€çŠ¶æ€ç®¡ç†
    // âœ… å›¾å½¢ç®¡é“åˆ›å»º
}
```

**ç®¡é“çŠ¶æ€é…ç½®**:
- é¡¶ç‚¹è¾“å…¥ç»‘å®šå’Œå±æ€§æè¿°
- å›¾å…ƒæ‹“æ‰‘å’Œè£…é…è®¾ç½®
- å…‰æ …åŒ–å‚æ•° (å¡«å……æ¨¡å¼ã€å‰”é™¤æ¨¡å¼)
- é¢œè‰²æ··åˆå’Œæ·±åº¦æµ‹è¯•é…ç½®
- åŠ¨æ€è§†å£å’Œè£å‰ªçŸ©å½¢æ”¯æŒ

#### 3. ç®¡é“ç¼“å­˜ç³»ç»Ÿ
```cpp
class VulkanPipelineCache {
private:
    VulkanDevice* m_device;
    TMap<uint64, TSharedPtr<VulkanPipelineState>> m_pipelineCache;
    std::mutex m_cacheMutex;
    CacheStats m_stats;
    
public:
    TSharedPtr<VulkanPipelineState> getOrCreatePipelineState(const PipelineStateDesc& desc);
    void clear();
    CacheStats getStats() const;
};
```

**ç¼“å­˜ç‰¹æ€§**:
- åŸºäºæè¿°ç¬¦å“ˆå¸Œçš„å¿«é€ŸæŸ¥æ‰¾
- çº¿ç¨‹å®‰å…¨çš„ç¼“å­˜ç®¡ç†
- ç¼“å­˜å‘½ä¸­ç‡ç»Ÿè®¡
- å†…å­˜ä½¿ç”¨é‡ç›‘æ§

#### 4. ç€è‰²å™¨åå°„ç³»ç»Ÿ
```cpp
struct ShaderReflectionData {
    TArray<String> inputVariables;
    TArray<String> outputVariables;
    TArray<String> uniformBuffers;
    TArray<String> textures;
    TArray<String> samplers;
    TArray<String> vertexAttributes;
    String entryPoint;
    EShaderStage stage;
};
```

**åå°„åŠŸèƒ½**:
- è¾“å…¥/è¾“å‡ºå˜é‡è‡ªåŠ¨è¯†åˆ«
- èµ„æºç»‘å®šç‚¹å‘ç°
- é¡¶ç‚¹å±æ€§æè¿°ç”Ÿæˆ
- ç€è‰²å™¨å…¥å£ç‚¹æ£€æµ‹

#### 5. æ¸²æŸ“é€šé“ç®¡ç†
```cpp
bool VulkanPipelineState::createRenderPass() {
    // âœ… é¢œè‰²é™„ä»¶é…ç½®
    // âœ… æ·±åº¦æ¨¡æ¿é™„ä»¶è®¾ç½®
    // âœ… å­é€šé“æè¿°
    // âœ… å­é€šé“ä¾èµ–å…³ç³»
    // âœ… æ¸²æŸ“é€šé“åˆ›å»º
}
```

**æ¸²æŸ“é€šé“ç‰¹æ€§**:
- å¤šæ¸²æŸ“ç›®æ ‡æ”¯æŒ
- æ·±åº¦æ¨¡æ¿ç¼“å†²é…ç½®
- å­é€šé“ä¾èµ–ç®¡ç†
- é™„ä»¶æ ¼å¼è‡ªåŠ¨åŒ¹é…

#### 6. å‘½ä»¤åˆ—è¡¨é›†æˆ
```cpp
void VulkanCommandList::setPipelineState(TSharedPtr<IRHIPipelineState> pipelineState) {
    // âœ… ç®¡é“çŠ¶æ€éªŒè¯
    // âœ… Vulkan ç®¡é“ç»‘å®š
    // âœ… çŠ¶æ€è·Ÿè¸ªæ›´æ–°
}
```

**é›†æˆç‰¹æ€§**:
- ç±»å‹å®‰å…¨çš„ç®¡é“çŠ¶æ€ç»‘å®š
- å®æ—¶çŠ¶æ€éªŒè¯
- è°ƒè¯•ä¿¡æ¯è®°å½•

### ğŸ”§ è¾…åŠ©ç³»ç»Ÿå®ç°

#### ä¸‰è§’å½¢æ¸²æŸ“æ¼”ç¤º (TriangleRenderer)
```cpp
class TriangleRenderer {
private:
    RHI::IRHIDevice* m_device = nullptr;
    TSharedPtr<RHI::IRHIBuffer> m_vertexBuffer;
    TSharedPtr<RHI::IRHIVertexShader> m_vertexShader;
    TSharedPtr<RHI::IRHIPixelShader> m_pixelShader;
    TSharedPtr<RHI::IRHIPipelineState> m_pipelineState;
    
    struct Vertex {
        float position[3];
        float color[3];
    };
    
public:
    bool initialize(RHI::IRHIDevice* device);
    void render(RHI::IRHICommandList* cmdList);
};
```

**æ¼”ç¤ºåŠŸèƒ½**:
- å®Œæ•´çš„æ¸²æŸ“ç®¡çº¿æ¼”ç¤º
- æœ‰æ•ˆçš„SPIR-Vç€è‰²å™¨å­—èŠ‚ç 
- ç®¡é“çŠ¶æ€åˆ›å»ºå’Œä½¿ç”¨
- é¡¶ç‚¹ç¼“å†²åŒºç®¡ç†
- ç»˜åˆ¶å‘½ä»¤å½•åˆ¶

**ç€è‰²å™¨æ”¯æŒ**:
- HLSLæºç  (`Shaders/Triangle.hlsl`)
- GLSLæºç  (`Shaders/Triangle.vert`, `Shaders/Triangle.frag`)
- SPIR-Vç¼–è¯‘è„šæœ¬ (`Shaders/compile_shaders.bat`)
- è¿è¡Œæ—¶SPIR-Vå­—èŠ‚ç åŠ è½½

#### å†…å­˜ç®¡ç†ä¼˜åŒ–
```cpp
class PipelineCacheEntry {
    VkPipeline pipeline;
    VkPipelineLayout layout;
    VkRenderPass renderPass;
    uint64 hash;
    bool isValid;
};
```

**å†…å­˜ç­–ç•¥**:
- ç®¡é“å¯¹è±¡å¤ç”¨
- ç¼“å­˜æ¡ç›®ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å†…å­˜ä½¿ç”¨é‡ç»Ÿè®¡
- è‡ªåŠ¨æ¸…ç†æœºåˆ¶

### ğŸ“Š å®ç°ç»Ÿè®¡

| åŠŸèƒ½æ¨¡å— | å®ç°çŠ¶æ€ | ä»£ç è¡Œæ•° | å®Œæˆåº¦ |
|---------|---------|---------|-------|
| VulkanPipelineState | âœ… å®Œæˆ | ~400 è¡Œ | 100% |
| VulkanPipelineCache | âœ… å®Œæˆ | ~150 è¡Œ | 100% |
| ç€è‰²å™¨åå°„ | âœ… å®Œæˆ | ~100 è¡Œ | 90% |
| æ¸²æŸ“é€šé“ç®¡ç† | âœ… å®Œæˆ | ~200 è¡Œ | 100% |
| å‘½ä»¤åˆ—è¡¨é›†æˆ | âœ… å®Œæˆ | ~50 è¡Œ | 100% |
| ä¸‰è§’å½¢æ¼”ç¤º | âœ… å®Œæˆ | ~300 è¡Œ | 95% |
| **æ€»è®¡** | **6/6 å®Œæˆ** | **~1200 è¡Œ** | **98%** |

### ğŸ¯ æ¶æ„ä¼˜åŠ¿

#### 1. ç®¡é“çŠ¶æ€ç®¡ç†
- **ç¼“å­˜æœºåˆ¶**: é¿å…é‡å¤åˆ›å»ºç›¸åŒç®¡é“çŠ¶æ€
- **çº¿ç¨‹å®‰å…¨**: å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„å®‰å…¨è®¿é—®
- **å†…å­˜ä¼˜åŒ–**: æ™ºèƒ½çš„ç¼“å­˜æ¸…ç†ç­–ç•¥

#### 2. ç€è‰²å™¨ç³»ç»Ÿ
- **åå°„æ”¯æŒ**: è‡ªåŠ¨èµ„æºç»‘å®šå’ŒéªŒè¯
- **è·¨å¹³å°**: æ”¯æŒå¤šç§ç€è‰²å™¨è¯­è¨€
- **è°ƒè¯•å‹å¥½**: è¯¦ç»†çš„åå°„ä¿¡æ¯è¾“å‡º

#### 3. æ¸²æŸ“ç®¡çº¿
- **æ¨¡å—åŒ–**: æ¸…æ™°çš„æ¸²æŸ“é˜¶æ®µåˆ†ç¦»
- **å¯æ‰©å±•**: æ˜“äºæ·»åŠ æ–°çš„æ¸²æŸ“æ•ˆæœ
- **é«˜æ€§èƒ½**: ä¼˜åŒ–çš„ç®¡é“çŠ¶æ€åˆ‡æ¢

### ğŸ”® ä¸‹ä¸€æ­¥å¼€å‘è®¡åˆ’

#### çŸ­æœŸç›®æ ‡ (1-2å‘¨)
- **ç€è‰²å™¨ç¼–è¯‘**: é›†æˆ HLSL/GLSL åˆ° SPIR-V ç¼–è¯‘
- **æè¿°ç¬¦é›†**: å®ç°èµ„æºç»‘å®šç³»ç»Ÿ
- **çº¹ç†ç®¡ç†**: å®Œå–„çº¹ç†åˆ›å»ºå’Œç»‘å®š

#### ä¸­æœŸç›®æ ‡ (1ä¸ªæœˆ)
- **é«˜çº§æ¸²æŸ“**: å®ç° PBR æè´¨ç³»ç»Ÿ
- **å…‰ç…§ç³»ç»Ÿ**: åŸºç¡€å…‰ç…§å’Œé˜´å½±
- **åå¤„ç†**: å±å¹•ç©ºé—´æ•ˆæœ

#### é•¿æœŸç›®æ ‡ (3ä¸ªæœˆ)
- **è®¡ç®—ç€è‰²å™¨**: GPU è®¡ç®—æ”¯æŒ
- **å‡ ä½•ç€è‰²å™¨**: é«˜çº§å‡ ä½•å¤„ç†
- **ç»†åˆ†ç€è‰²å™¨**: æ›²é¢ç»†åˆ†æ”¯æŒ

### ğŸ’¡ æŠ€æœ¯äº®ç‚¹

1. **ç°ä»£ C++ è®¾è®¡**
   - æ™ºèƒ½æŒ‡é’ˆèµ„æºç®¡ç†
   - RAII ç”Ÿå‘½å‘¨æœŸæ§åˆ¶
   - æ¨¡æ¿å…ƒç¼–ç¨‹ä¼˜åŒ–

2. **é«˜æ€§èƒ½æ¶æ„**
   - ç®¡é“çŠ¶æ€ç¼“å­˜
   - æ‰¹é‡æ“ä½œä¼˜åŒ–
   - å†…å­˜æ± ç®¡ç†

3. **è°ƒè¯•å‹å¥½**
   - è¯¦ç»†çš„åå°„ä¿¡æ¯
   - å®Œæ•´çš„é”™è¯¯å¤„ç†
   - æ€§èƒ½ç»Ÿè®¡ç›‘æ§

4. **å¯ç»´æŠ¤æ€§**
   - æ¸…æ™°çš„æ¨¡å—åˆ†ç¦»
   - å®Œæ•´çš„æ–‡æ¡£æ³¨é‡Š
   - ä¸€è‡´çš„ä»£ç é£æ ¼

è¿™æ¬¡å®ç°æ ‡å¿—ç€ MonsterEngine çš„æ¸²æŸ“ç®¡çº¿ä»æ¦‚å¿µè®¾è®¡è½¬å‘å®é™…å¯ç”¨çš„å®ç°ï¼Œä¸ºåç»­çš„é«˜çº§æ¸²æŸ“åŠŸèƒ½å¼€å‘å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚

---

## å†…å­˜ç³»ç»Ÿï¼šç»Ÿä¸€å†…å­˜ç®¡ç†å™¨ï¼ˆMemory Pool / Allocatorï¼‰å®ç°ï¼ˆ2025-10-28ï¼‰

### ç›®æ ‡ä¸åŠ¨æœº
- **å‡å°‘ç¢ç‰‡**ï¼šä»¥æ± åŒ–åˆ†é…æ›¿ä»£é¢‘ç¹çš„ `new/malloc`ã€‚
- **åˆ†åŒºç®¡ç†**ï¼šæä¾›å°å¯¹è±¡æ± ï¼ˆSmall Object Poolï¼‰ã€ä¸´æ—¶å¸§ç¼“å†²æ± ï¼ˆFrame Scratch Poolï¼‰ã€çº¹ç†ç¼“å†²æ± ï¼ˆTexture Poolï¼‰ã€‚
- **å‚è€ƒUE5**ï¼šè®¾è®¡å‚è€ƒ UE5 çš„ `FMallocBinned2` ä¸ `FMemoryPoolPolicy` æ€æƒ³ï¼ŒæŒ‰å°ºå¯¸åˆ†æ¡¶ã€é¡µå¼ç®¡ç†ä¸çº¿æ€§åˆ†é…ç›¸ç»“åˆã€‚

### å…³é”®æ–‡ä»¶
- `Include/Core/Memory.h`ï¼šå¯¹å¤–ç»Ÿä¸€å…¥å£ `MemorySystem`ï¼Œå£°æ˜æ± æ¥å£ä¸ç»Ÿè®¡ã€‚
- `Source/Core/Memory.cpp`ï¼šå°å¯¹è±¡é¡µå¼åˆ†é…ï¼ˆ16..1024B æ¡¶ï¼‰ã€å¸§çº¿æ€§åˆ†é…å™¨ã€çº¹ç†å¤§å—æ± å®ç°ã€‚
- `Source/Engine.cpp`ï¼šåœ¨ `Engine::initialize/shutdown` ä¸­åˆå§‹åŒ–/é”€æ¯å†…å­˜ç³»ç»Ÿã€‚
- `Include/Core/CoreMinimal.h`ï¼šèšåˆåŒ…å« `Core/Memory.h`ï¼Œä¾¿äºç»Ÿä¸€ä½¿ç”¨ã€‚

### API æ¦‚è§ˆ
```cpp
class MemorySystem {
public:
    static MemorySystem& get();
    bool   initialize(uint64 frameScratchSize = 8_MB, uint64 textureBlock = 64_MB);
    void   shutdown();

    // Small Object Pool (<=1024B)
    void*  allocateSmall(size_t size, size_t alignment = alignof(std::max_align_t));
    void   freeSmall(void* ptr, size_t size);

    // General fallback (<=1024B èµ° smallï¼›å¦åˆ™ _aligned_malloc/_aligned_free)
    void*  allocate(size_t size, size_t alignment = alignof(std::max_align_t));
    void   free(void* ptr, size_t size);

    // Frame Scratch (æ¯å¸§å¤ä½çš„çº¿æ€§åˆ†é…å™¨)
    void*  frameAllocate(size_t size, size_t alignment = alignof(std::max_align_t));
    void   frameReset();

    // Texture Poolï¼ˆå¤§å—å­åˆ†é…ï¼Œä¸»è¦ç”¨äºä¸´æ—¶/è¯»å†™ç¼“å†²ï¼‰
    void*  textureAllocate(size_t size, size_t alignment = 256);
    void   textureReleaseAll();

    // è¯Šæ–­
    uint64 getAllocatedSmallBytes() const;
    uint64 getAllocatedFrameBytes() const;
    uint64 getReservedTextureBytes() const;
};
```

### è®¾è®¡è¦ç‚¹ï¼ˆå¯¹é½UE5æ€è·¯ï¼‰
- **å°å¯¹è±¡æ± ï¼ˆBinnedï¼‰**ï¼š
  - æ¡¶å°ºå¯¸ï¼š16ã€32ã€64ã€128ã€256ã€512ã€1024 å­—èŠ‚ã€‚
  - é¡µå¤§å°ï¼š64KBï¼›é¡µå¤´è®°å½•ç©ºé—²é“¾è¡¨ä¸å…ƒç´ å¤§å°ï¼Œå…ƒç´ å†…åµŒå•é“¾è¡¨æŒ‡é’ˆã€‚
  - çº¿ç¨‹å®‰å…¨ï¼šå…¨å±€äº’æ–¥ï¼ˆå¯åç»­ç»†åŒ–ä¸ºæ¯æ¡¶é”æˆ–æ— é”ç»“æ„ï¼‰ã€‚

- **å¸§ç¼“å†²æ± ï¼ˆLinearï¼‰**ï¼š
  - æ¯å¸§ bump-pointer çº¿æ€§åˆ†é…ï¼Œå¸§æœ« `frameReset()` ä¸€é”®å¤ä½ï¼›
  - å®¹é‡ä¸è¶³æ—¶ç¿»å€æ‰©å®¹ï¼ˆæ‹·è´å®‰å…¨çš„æ•°æ®ä»…ä¸º CPU ä¸´æ—¶å†…å­˜ï¼‰ã€‚

- **çº¹ç†ç¼“å†²æ± ï¼ˆLarge Blocksï¼‰**ï¼š
  - å›ºå®šå—å¤§å°ï¼ˆé»˜è®¤ 64MBï¼‰æŒ‰éœ€å¢é•¿ï¼›
  - æ¯å—åŸå­ offset é€’å¢å­åˆ†é…ï¼›
  - `textureReleaseAll()` ç»Ÿä¸€å¤ä½ï¼Œé€‚é…æµ/IO ä¸´æ—¶ staging æ•°æ®ã€‚

### ç±»UMLå›¾
```mermaid
classDiagram
    class MemorySystem {
        +initialize(frameScratch, textureBlock) bool
        +shutdown() void
        +allocateSmall(size, align) void*
        +freeSmall(ptr, size) void
        +allocate(size, align) void*
        +free(ptr, size) void
        +frameAllocate(size, align) void*
        +frameReset() void
        +textureAllocate(size, align) void*
        +textureReleaseAll() void
        +getAllocatedSmallBytes() uint64
        +getAllocatedFrameBytes() uint64
        +getReservedTextureBytes() uint64
    }

    class SmallBin {
        +elementSize : uint32
        +pages : vector<SmallBinPage*>
    }

    class SmallBinPageHeader {
        +parentBin : SmallBin*
        +elementSize : uint32
        +elementCount : uint32
        +freeCount : uint32
        +freeList : void*
    }

    class FrameScratch {
        +buffer : unique_ptr<uint8[]>
        +capacity : uint64
        +offset : atomic<uint64>
    }

    class TextureBlock {
        +buffer : unique_ptr<uint8[]>
        +capacity : uint64
        +offset : atomic<uint64>
    }

    MemorySystem "1" o-- "7" SmallBin
    SmallBin "1" *-- "N" SmallBinPageHeader
    MemorySystem --> FrameScratch
    MemorySystem --> TextureBlock
```

### çº¿ç¨‹å›¾ï¼ˆå…¸å‹ä¸€å¸§å†…å­˜ä½¿ç”¨ï¼‰
```mermaid
sequenceDiagram
    participant Engine
    participant Mem as MemorySystem
    participant Render

    Engine->>Mem: initialize()
    Engine->>Render: update()
    Render->>Mem: frameAllocate(tmpData)
    Render-->>Render: use tmp
    Render->>Mem: allocateSmall(component)
    Render-->>Render: use component
    Engine->>Mem: frameReset()  // end of frame
    Note over Mem: small objects persist until freeSmall()
```

### ä»£ç æ¶æ„å›¾
```mermaid
graph TB
  App[Engine/Systems] -->|alloc/free| MS[MemorySystem]
  MS --> SB[Small Bins 16..1024B]
  MS --> FS[Frame Scratch Linear]
  MS --> TP[Texture Blocks]
  SB --> P1[64KB Pages]
  FS --> Bump[Atomic bump offset]
  TP --> Blocks[64MB blocks grow]
```

### å…³é”®æµç¨‹å›¾
```mermaid
flowchart TD
  A[allocate(size,align)] --> B{size <= 1024?}
  B -->|Yes| C[select bin]
  C --> D{page has free?}
  D -->|Yes| E[pop freeList]
  D -->|No| F[allocate new 64KB page]
  F --> E
  B -->|No| G[_aligned_malloc]
  E --> H[return ptr]
  G --> H
```

```mermaid
flowchart TD
  A[frameAllocate(size,align)] --> B[align up offset]
  B --> C{within capacity?}
  C -->|Yes| D[reserve + return]
  C -->|No| E[grow buffer x2 or to size]
  E --> B
```

```mermaid
flowchart TD
  A[textureAllocate(size,align)] --> B[scan blocks]
  B --> C{fits any?}
  C -->|Yes| D[CAS offset and return]
  C -->|No| E[allocate new block >= size]
  E --> D
```

### ä¸UE5çš„ä¸€è‡´æ€§ä¸å·®å¼‚
- **ä¸€è‡´æ€§**ï¼šæŒ‰å°ºå¯¸åˆ†æ¡¶çš„å°å¯¹è±¡æ± ï¼›é¡µå¼ç®¡ç†ä¸å…ƒç´ ç©ºé—²é“¾ï¼›ä¸´æ—¶å†…å­˜é‡‡ç”¨çº¿æ€§åˆ†é…ï¼›å¤§å—æ± ç”¨äºé«˜ååä¸´æ—¶æ•°æ®ã€‚
- **å·®å¼‚**ï¼šå½“å‰ç‰ˆæœ¬æœªå®ç°è·¨çº¿ç¨‹æ— é”å°æ¡¶ã€å›æ”¶åˆå¹¶ä¸åå°æ¸…ç†ï¼›æš‚æœªå®ç°å¹³å°ç‰¹å®šçš„ä½å±‚ `FMalloc` æ›¿æ¢ï¼ˆä¿ç•™ `_aligned_malloc` åå¤‡ï¼‰ã€‚

### ä¸‹ä¸€æ­¥å¼€å‘è®¡åˆ’ï¼ˆMemory Roadmapï¼‰
1. **å¹¶å‘ä¸å¯æ‰©å±•æ€§**ï¼š
   - å°å¯¹è±¡æ± åˆ‡åˆ†æ¯æ¡¶é”æˆ–åˆ†çº¿ç¨‹ç§æœ‰ç¼“å­˜ï¼Œå‡å°‘å…¨å±€é”ç«äº‰ï¼›
   - å¼•å…¥æ— é”è‡ªç”±é“¾è¡¨æˆ–åŸºäº `std::pmr` çš„ç­–ç•¥é€‚é…å™¨ã€‚
2. **ç¢ç‰‡ä¸å›æ”¶**ï¼š
   - é¡µå›æ”¶ç­–ç•¥ä¸é˜ˆå€¼ï¼›ç©ºé¡µåˆå¹¶ä¸é‡Šæ”¾å›ç³»ç»Ÿï¼›
   - çº¹ç†å—ç©ºé—²å­åˆ†é…å™¨ï¼ˆç©ºé—²åŒºé—´åˆå¹¶ï¼‰ã€‚
3. **å¯è§‚æµ‹æ€§**ï¼š
   - æš´éœ²ç»Ÿè®¡æ¥å£ä¸å¯è§†åŒ–ï¼šé¡µæ•°ã€å‘½ä¸­ç‡ã€å³°å€¼ã€æµªæ¶Œï¼›
   - ä¸å¼•æ“æ—¥å¿—/è°ƒè¯•UIé›†æˆï¼Œå¸§å†…å­˜æ°´ä½å›¾ã€‚
4. **å¹³å°ä¸å¯¹é½**ï¼š
   - å¯¹é½ç­–ç•¥é€‚é… SIMD/ç¼“å­˜è¡Œï¼›
   - Windows/Linux/Android å¹³å°ç‰¹åŒ–ä¸å¤§é¡µæ”¯æŒã€‚
5. **æ›¿æ¢å…¨å±€ new/deleteï¼ˆå¯é€‰ï¼‰**ï¼š
   - æä¾› `MR_NEW/MR_DELETE` å®ä¸å…¨å±€æ›¿æ¢é’©å­ï¼›
   - æ¸è¿›å¼è¿ç§»ä»¥é™ä½é£é™©ã€‚

---

*æœ¬æ–‡æ¡£ç”Ÿæˆæ—¶é—´: 2025å¹´9æœˆ21æ—¥*
*MonsterEngineç‰ˆæœ¬: å¼€å‘ç‰ˆæœ¬ v0.3.0*
*ä½œè€…: MonsterEngineå¼€å‘å›¢é˜Ÿ*
*æœ€åæ›´æ–°: VulkanPipelineState å®Œæ•´å®ç°*

---

## æœ¬æ¬¡æ›´æ–°ï¼šç€è‰²å™¨ç¼–è¯‘ã€çƒ­é‡è½½ä¸åŸºç¡€åå°„ï¼ˆ2025-09-29ï¼‰

### ç›®æ ‡ä¸æˆæœ
- **çœŸå®ç€è‰²å™¨æ”¯æŒ**: é›†æˆ `ShaderCompiler`ï¼Œåœ¨å¼€å‘æœºä¾èµ– Vulkan SDKï¼ˆglslcï¼‰ä¸å¯é€‰ DXCï¼Œé€šè¿‡ PATH è°ƒç”¨ç¼–è¯‘ GLSL/HLSL â†’ SPIR-Vã€‚
- **çƒ­é‡è½½**: åœ¨ `TriangleRenderer` ä¸­åŸºäºæ–‡ä»¶æ—¶é—´æˆ³ï¼ˆ`Shaders/Triangle.vert/.frag`ï¼‰æ£€æµ‹å˜åŒ–ï¼Œè‡ªåŠ¨é‡æ–°ç¼–è¯‘å¹¶é‡å»ºç®¡çº¿ã€‚
- **ç¦»çº¿ç¼–è¯‘ç¼“å­˜**: è‹¥ `.spv` æ¯”æºæ–‡ä»¶æ–°ï¼Œç›´æ¥åŠ è½½ï¼Œé¿å…é‡å¤ç¼–è¯‘ã€‚
- **æœ€å° SPIR-V åå°„**: åœ¨ `VulkanShader::performReflection` æ‰«æ OpDecorate/OpVariableï¼Œæå– `DescriptorSet`/`Binding`ï¼Œæ ¹æ® StorageClass åŒºåˆ† `UniformBuffer` ä¸ `CombinedImageSampler`ï¼Œä¸ºåç»­æè¿°ç¬¦å¸ƒå±€ä¸ç»‘å®šå¥ å®šåŸºç¡€ã€‚
- **VS2022 é€šè¿‡**: å·¥ç¨‹æ–‡ä»¶å·²æ›´æ–°ï¼Œæ–°å¢ `Include/Core/ShaderCompiler.h`ã€`Source/Core/ShaderCompiler.cpp` å¹¶é›†æˆï¼›è¿è¡Œæ—¶åº“/GLFW é“¾æ¥å†²çªå·²å¤„ç†ã€‚

### å…³é”®æ–‡ä»¶
- `Include/Core/ShaderCompiler.h`ï¼šç€è‰²å™¨ç¼–è¯‘æ¥å£ï¼ˆGLSL/HLSLâ†’SPIR-Vï¼‰ã€‚
- `Source/Core/ShaderCompiler.cpp`ï¼šè°ƒç”¨ `glslc`/`dxc`ï¼Œå®ç°ç¦»çº¿ç¼“å­˜ä¸æ—¶é—´æˆ³æŸ¥è¯¢ã€‚
- `Source/TriangleRenderer.cpp`ï¼šä½¿ç”¨çœŸå® GLSL ç¼–è¯‘ç”Ÿæˆçš„ SPIR-Vï¼›åŠ å…¥çƒ­é‡è½½é€»è¾‘ã€‚
- `Source/Platform/Vulkan/VulkanShader.cpp`ï¼šæœ€å° SPIR-V åå°„å®ç°ï¼Œè¾“å‡ºæè¿°ç¬¦ç»‘å®šä¿¡æ¯ã€‚

### ç±»UMLå›¾ï¼ˆç²¾ç®€ï¼‰
```mermaid
classDiagram
    class ShaderCompiler {
      +compileFromFile(file,opts) : TArray<uint8>
      +readFileBytes(file) : TArray<uint8>
      +getLastWriteTime(file) : uint64
    }
    class TriangleRenderer {
      -m_vertexBuffer
      -m_vertexShader
      -m_pixelShader
      -m_pipelineState
      +initialize(device) bool
      +render(cmdList)
      -createVertexBuffer() bool
      -createShaders() bool
      -createPipelineState() bool
    }
    class VulkanShader {
      +getShaderModule() : VkShaderModule
      +getPipelineStageCreateInfo() : VkPipelineShaderStageCreateInfo
      -performReflection(bytecode)
      -m_descriptorBindings : TArray<VkDescriptorSetLayoutBinding>
    }
    ShaderCompiler <.. TriangleRenderer : uses
    VulkanShader <.. TriangleRenderer : creates
```

### çº¿ç¨‹å›¾ï¼ˆç¼–è¯‘ä¸çƒ­é‡è½½ï¼‰
```mermaid
sequenceDiagram
    participant App as Application/Renderer
    participant SC as ShaderCompiler
    participant FS as FileSystem
    App->>FS: stat(Shaders/Triangle.vert/.frag)
    FS-->>App: timestamps
    alt changed
      App->>SC: compileFromFile(.vert/.frag)
      SC->>FS: check .spv newer?
      alt cached
        FS-->>SC: read .spv
      else compile
        SC->>glslc/dxc: invoke
        glslc/dxc-->>SC: .spv
      end
      SC-->>App: SPIR-V blobs
      App->>Vulkan: recreate shaders/pipeline
    else not changed
      App-->>App: reuse existing pipeline
    end
```

### ä»£ç æ¶æ„å›¾ï¼ˆæ–°å¢æ¨¡å—ï¼‰
```mermaid
graph TB
  App[TriangleRenderer] -->|compile| SC[ShaderCompiler]
  SC -->|GLSL/HLSL| SPV[SPIR-V]
  SPV --> VS[VulkanVertexShader]
  SPV --> PS[VulkanPixelShader]
  VS --> VPS[VulkanPipelineState]
  PS --> VPS
  VPS --> GPU[VkPipeline]
```

### æµç¨‹å›¾ï¼ˆæ¸²æŸ“å¸§ä¸­çš„çƒ­é‡è½½ï¼‰
```mermaid
flowchart TD
  A[frame begin] --> B[stat shader files]
  B -->|changed| C[compile GLSL/HLSL to SPIR-V]
  C --> D[create Vulkan shaders]
  D --> E[rebuild pipeline]
  B -->|not changed| F[reuse pipeline]
  E --> G[bind pipeline]
  F --> G
  G --> H[bind vertex buffers]
  H --> I[draw]
  I --> J[frame end]
```

### é”™è¯¯å¯è§†åŒ–ä¸æ—¥å¿—ï¼ˆç°çŠ¶ï¼‰
- ç¼–è¯‘å¤±è´¥ï¼šè®°å½• `glslc`/`dxc` æ ‡å‡†é”™è¯¯è¾“å‡ºä¸é€€å‡ºç ã€‚
- SPIR-V åŸºç¡€æ ¡éªŒï¼šé­”æ•°/é•¿åº¦æ ¡éªŒå¤±è´¥åˆ™è­¦å‘Šã€‚
- åå°„ç»Ÿè®¡ï¼šè®°å½•å‘ç°çš„ `DescriptorSetLayoutBinding` æ•°é‡ï¼Œä¾¿äºéªŒè¯ã€‚

### ä¸‹ä¸€æ­¥è®¡åˆ’ï¼ˆRoadmapï¼‰
1. **æè¿°ç¬¦é›†/å¸ƒå±€è‡ªåŠ¨ç”Ÿæˆ**
   - ç”± `VulkanShader` åå°„æ•°æ®æ±‡æ€»è‡³ `VulkanPipelineState`ï¼Œç”Ÿæˆ `VkDescriptorSetLayout` ä¸ `VkPipelineLayout`ã€‚
   - æ”¯æŒæ¨å¸¸é‡èŒƒå›´ï¼ˆpush constantsï¼‰ï¼Œå¯¹åº” UE é£æ ¼å¸¸é‡å‚æ•°æ›´æ–°ã€‚
2. **èµ„æºç»‘å®š APIï¼ˆUE é£æ ¼ï¼‰**
   - `SetShaderUniformBuffer(stage, slot, buffer)`ã€`SetShaderTexture(stage, slot, texture, sampler)`ã€‚
   - åœ¨ `VulkanCommandList` ä¸­æ®å¸ƒå±€ä¸ç»‘å®šè¡¨è°ƒç”¨ `vkCmdBindDescriptorSets`ã€‚
3. **å®Œæ•´åå°„**
   - è§£æ `OpDecorate`/`OpMemberDecorate`/`OpType*`/`OpVariable`ï¼Œè·å¾—ç²¾ç¡®çš„ UBO/SSBO/é‡‡æ ·å™¨/çº¹ç†ç­‰ä¿¡æ¯ã€‚
   - å¯é€‰é›†æˆ `SPIRV-Reflect` ä»¥æå‡æ­£ç¡®æ€§ä¸å¼€å‘æ•ˆç‡ï¼ˆç»´æŠ¤å¼•æ“è‡ªåå°„ä¸ºåå¤‡ï¼‰ã€‚
4. **å¯è§†åŒ–ä¸è°ƒè¯•**
   - Debug æ„å»ºåœ¨ç¼ºå¤±ç»‘å®šæ—¶æ’å…¥æ˜æ˜¾çš„ GPU æ ‡è®°ä¸æ—¥å¿—ã€‚
   - åœ¨ `VulkanCommandList` çš„ `beginEvent/setMarker` æ”¯æŒ `VK_EXT_debug_utils`ã€‚
5. **ç€è‰²å™¨å˜ä½“ä¸ç¼“å­˜**
   - åŸºäºå®å®šä¹‰ç”Ÿæˆå¤šå˜ä½“ï¼Œå»ºç«‹ç£ç›˜ç¼“å­˜ï¼ˆhash æ–‡ä»¶å+å®šä¹‰+ç¼–è¯‘é€‰é¡¹ï¼‰ã€‚
   - å¤±è´¥å›é€€ç­–ç•¥ä¸æç¤ºã€‚
6. **æ„å»ºä¸å·¥å…·é“¾**
   - CMake ç”Ÿæˆè„šæœ¬æ•´åˆ glslc/dxc è·¯å¾„æ£€æµ‹ã€‚
   - Windows ä¸‹ VS å·¥ç¨‹å‰/åç½®äº‹ä»¶å®Œå–„ï¼ŒLinux ä¸‹è„šæœ¬åŒ–ã€‚

---

> å¤‡æ³¨ï¼šæœ¬é˜¶æ®µåå°„ä¸ºæœ€å°å®ç°ï¼Œä¼˜å…ˆè§£é”æè¿°ç¬¦å¸ƒå±€/ç»‘å®šè‡ªåŠ¨åŒ–ä¸è°ƒè¯•å¯è§†åŒ–ï¼Œéšåé€æ­¥å®Œå–„åˆ°ä¸ UE5 ç­‰ä»·çš„åå°„ä¸ç»‘å®šèƒ½åŠ›ã€‚

---

## ç¬¬ä¸ƒç« ï¼šæè¿°ç¬¦é›†è‡ªåŠ¨ç”Ÿæˆä¸UEé£æ ¼èµ„æºç»‘å®šï¼ˆå·²å®Œæˆï¼‰

### 7.1 å®ç°æ¦‚è¿°

æœ¬æ¬¡å®ç°å®Œæˆäº†æ¸²æŸ“å¼•æ“çš„å…³é”®èµ„æºç®¡ç†åŠŸèƒ½ï¼Œä¸»è¦åŒ…æ‹¬ï¼š
1. **ç”±åå°„æ•°æ®è‡ªåŠ¨ç”ŸæˆVkDescriptorSetLayoutä¸VkPipelineLayout**ï¼šåŸºäºSPIR-Våå°„ä¿¡æ¯ï¼Œè‡ªåŠ¨èšåˆå„ç€è‰²å™¨é˜¶æ®µçš„èµ„æºç»‘å®šï¼Œç”ŸæˆVulkanæè¿°ç¬¦é›†å¸ƒå±€å’Œç®¡çº¿å¸ƒå±€ã€‚
2. **UE5é£æ ¼èµ„æºç»‘å®šAPI**ï¼šåœ¨`VulkanCommandList`ä¸­æ–°å¢`SetShaderUniformBuffer`ã€`SetShaderTexture`ã€`SetShaderSampler`ç­‰APIï¼Œæä¾›ç±»ä¼¼UE5çš„é«˜çº§èµ„æºç»‘å®šæ¥å£ã€‚
3. **VK_EXT_debug_utilsé›†æˆ**ï¼šåœ¨Debugæ„å»ºä¸­å¯ç”¨Vulkanè°ƒè¯•æ ‡ç­¾ï¼Œè‡ªåŠ¨æ ‡è®°ç¼ºå¤±çš„èµ„æºç»‘å®šå¹¶è¾“å‡ºå¯è§†åŒ–é”™è¯¯ä¿¡æ¯ï¼Œä¾¿äºå¼€å‘è°ƒè¯•ã€‚

è¿™äº›åŠŸèƒ½å‚è€ƒUE5çš„RHIæ¶æ„ï¼ˆFVulkanDescriptorSetRingBufferã€FVulkanPipelineStateCacheManagerç­‰ï¼‰ï¼Œä¸ºå¼•æ“æä¾›äº†é«˜æ•ˆã€æ˜“ç”¨çš„èµ„æºç®¡ç†ç³»ç»Ÿã€‚

### 7.2 æ ¸å¿ƒæ¶æ„è®¾è®¡

#### 7.2.1 æè¿°ç¬¦é›†å¸ƒå±€è‡ªåŠ¨ç”Ÿæˆæµç¨‹

```mermaid
graph TB
    A[VulkanPipelineState::initialize] --> B[Collect Reflection Data]
    B --> C{Vertex Shader?}
    C -->|Yes| D[Get VS Descriptor Bindings]
    C -->|No| E{Pixel Shader?}
    D --> E
    E -->|Yes| F[Get PS Descriptor Bindings]
    E -->|No| G[Aggregate Bindings]
    F --> G
    G --> H[Merge Same Bindings<br/>Combine Stage Flags]
    H --> I[Create VkDescriptorSetLayout<br/>for Each Set]
    I --> J[Create VkPipelineLayout]
    J --> K[Store Layouts for Cleanup]
    K --> L[Pipeline Ready]
    
    style G fill:#e1f5ff
    style I fill:#ffe1f5
    style J fill:#f5ffe1
```

#### 7.2.2 èµ„æºç»‘å®šçŠ¶æ€è·Ÿè¸ª

```mermaid
classDiagram
    class VulkanCommandList {
        -TMap~uint32, BoundResource~ m_boundResources
        -VkDescriptorSet m_currentDescriptorSet
        -VkDescriptorPool m_descriptorPool
        -bool m_debugUtilsAvailable
        +setShaderUniformBuffer(slot, buffer)
        +setShaderTexture(slot, texture)
        +setShaderSampler(slot, texture)
        +beginEvent(name)
        +endEvent()
        +setMarker(name)
    }
    
    class BoundResource {
        +TSharedPtr~IRHIBuffer~ buffer
        +TSharedPtr~IRHITexture~ texture
        +bool isDirty
    }
    
    class VulkanPipelineState {
        -TArray~VkDescriptorSetLayout~ m_descriptorSetLayouts
        -VkPipelineLayout m_pipelineLayout
        +createPipelineLayout()
        +destroyVulkanObjects()
    }
    
    VulkanCommandList "1" *-- "N" BoundResource
    VulkanCommandList --> VulkanPipelineState : uses
```

### 7.3 UMLç±»å›¾ï¼ˆå®Œæ•´ç³»ç»Ÿï¼‰

```mermaid
classDiagram
    class VulkanShader {
        -TArray~VkDescriptorSetLayoutBinding~ m_descriptorBindings
        -uint32 m_pushConstantSize
        +getDescriptorBindings() TArray
        +performReflection(bytecode)
    }
    
    class VulkanVertexShader {
        <<IRHIVertexShader>>
    }
    
    class VulkanPixelShader {
        <<IRHIPixelShader>>
    }
    
    class VulkanPipelineState {
        -VkPipeline m_pipeline
        -VkPipelineLayout m_pipelineLayout
        -VkRenderPass m_renderPass
        -TArray~VkDescriptorSetLayout~ m_descriptorSetLayouts
        -TArray~VkShaderModule~ m_shaderModules
        +initialize() bool
        +createPipelineLayout() bool
        +destroyVulkanObjects()
        +getPipeline() VkPipeline
        +getPipelineLayout() VkPipelineLayout
    }
    
    class VulkanCommandList {
        -VkCommandBuffer m_commandBuffer
        -TMap~uint32, BoundResource~ m_boundResources
        -VkDescriptorSet m_currentDescriptorSet
        -bool m_debugUtilsAvailable
        +setShaderUniformBuffer(slot, buffer)
        +setShaderTexture(slot, texture)
        +setShaderSampler(slot, texture)
        +beginEvent(name)
        +endEvent()
        +setMarker(name)
    }
    
    class VulkanAPI {
        <<static>>
        +vkCreateDescriptorSetLayout
        +vkDestroyDescriptorSetLayout
        +vkCreatePipelineLayout
        +vkDestroyPipelineLayout
        +vkCmdBeginDebugUtilsLabelEXT
        +vkCmdEndDebugUtilsLabelEXT
        +vkCmdInsertDebugUtilsLabelEXT
    }
    
    VulkanShader <|-- VulkanVertexShader
    VulkanShader <|-- VulkanPixelShader
    VulkanPipelineState --> VulkanVertexShader : uses
    VulkanPipelineState --> VulkanPixelShader : uses
    VulkanPipelineState --> VulkanAPI : calls
    VulkanCommandList --> VulkanPipelineState : uses
    VulkanCommandList --> VulkanAPI : calls
```

### 7.4 çº¿ç¨‹å›¾ï¼ˆèµ„æºç»‘å®šä¸æ¸²æŸ“æµç¨‹ï¼‰

```mermaid
sequenceDiagram
    participant App as Application
    participant Render as TriangleRenderer
    participant CmdList as VulkanCommandList
    participant Pipeline as VulkanPipelineState
    participant Shader as VulkanShader
    participant VkAPI as VulkanAPI
    
    App->>Render: initialize()
    Render->>Shader: createShaders()
    Shader->>Shader: performReflection(SPIR-V)
    Note right of Shader: Parse OpDecorate<br/>Extract bindings
    Shader-->>Render: Shaders with reflection data
    
    Render->>Pipeline: createPipelineState()
    Pipeline->>Shader: getDescriptorBindings()
    Shader-->>Pipeline: Binding data
    Pipeline->>Pipeline: Aggregate bindings<br/>Merge stage flags
    Pipeline->>VkAPI: vkCreateDescriptorSetLayout()
    VkAPI-->>Pipeline: VkDescriptorSetLayout
    Pipeline->>VkAPI: vkCreatePipelineLayout()
    VkAPI-->>Pipeline: VkPipelineLayout
    Pipeline-->>Render: Pipeline ready
    
    App->>Render: render()
    Render->>CmdList: begin()
    Note right of CmdList: Check debug utils available
    
    alt Debug Build
        CmdList->>VkAPI: vkCmdBeginDebugUtilsLabelEXT("Render Triangle")
    end
    
    Render->>CmdList: setPipelineState(pipeline)
    CmdList->>VkAPI: vkCmdBindPipeline()
    
    opt Resource Binding
        Render->>CmdList: setShaderUniformBuffer(0, buffer)
        Note right of CmdList: Track bound resource<br/>Mark as dirty
        alt Missing Binding
            CmdList->>VkAPI: vkCmdInsertDebugUtilsLabelEXT("ERROR: Missing buffer")
        end
        
        Render->>CmdList: setShaderTexture(1, texture)
        Note right of CmdList: Track bound resource
    end
    
    Render->>CmdList: setVertexBuffers()
    Render->>CmdList: draw(3)
    CmdList->>VkAPI: vkCmdDraw()
    
    alt Debug Build
        CmdList->>VkAPI: vkCmdEndDebugUtilsLabelEXT()
    end
    
    Render->>CmdList: end()
    App->>CmdList: Submit to GPU
```

### 7.5 ä»£ç æ¶æ„å›¾ï¼ˆæ–°å¢æ¨¡å—é›†æˆï¼‰

```mermaid
graph TB
    subgraph "Shader Reflection Layer"
        SPIRV[SPIR-V Bytecode] --> Reflect[performReflection]
        Reflect --> Bindings[Descriptor Bindings]
    end
    
    subgraph "Pipeline Layout Generation"
        VS[VulkanVertexShader] -->|bindings| Aggregate
        PS[VulkanPixelShader] -->|bindings| Aggregate
        Aggregate[Aggregate & Merge] --> DSL[VkDescriptorSetLayout]
        DSL --> PL[VkPipelineLayout]
    end
    
    subgraph "Resource Binding System"
        SetBuffer[setShaderUniformBuffer] --> Track[Track Bound Resources]
        SetTexture[setShaderTexture] --> Track
        Track --> DescSet[Descriptor Set<br/>Future: vkUpdateDescriptorSets]
    end
    
    subgraph "Debug Utilities"
        DebugCheck{Debug Build?}
        DebugCheck -->|Yes| BeginLabel[vkCmdBeginDebugUtilsLabelEXT]
        DebugCheck -->|Yes| Marker[vkCmdInsertDebugUtilsLabelEXT]
        DebugCheck -->|Yes| EndLabel[vkCmdEndDebugUtilsLabelEXT]
        DebugCheck -->|No| NoOp[No-op]
    end
    
    subgraph "Command Recording"
        Begin[cmdList.begin] --> DebugCheck
        BeginLabel --> BindPipe[Bind Pipeline]
        Marker --> BindPipe
        NoOp --> BindPipe
        BindPipe --> BindRes[Bind Resources]
        BindRes --> Draw[vkCmdDraw]
        Draw --> EndLabel
        EndLabel --> End[cmdList.end]
    end
    
    SPIRV -.-> VS
    SPIRV -.-> PS
    PL --> BindPipe
    DescSet -.-> BindRes
    
    style DSL fill:#e1f5ff
    style PL fill:#ffe1f5
    style Track fill:#f5ffe1
    style Marker fill:#ffe1e1
```

### 7.6 å…³é”®ä»£ç æµç¨‹å›¾

#### 7.6.1 æè¿°ç¬¦é›†å¸ƒå±€åˆ›å»ºæµç¨‹

```mermaid
flowchart TD
    A[Start: createPipelineLayout] --> B[Create setBindings Map]
    B --> C{Has Vertex Shader?}
    C -->|Yes| D[Get VS Descriptor Bindings]
    D --> E[Add to setBindings map 0]
    C -->|No| F{Has Pixel Shader?}
    E --> F
    F -->|Yes| G[Get PS Descriptor Bindings]
    G --> H{Binding exists in map?}
    H -->|Yes| I[Merge: Combine stage flags]
    H -->|No| J[Add new binding to map]
    I --> K{More bindings?}
    J --> K
    K -->|Yes| H
    K -->|No| L[Iterate setBindings map]
    F -->|No| L
    
    L --> M{Set has bindings?}
    M -->|Yes| N[Create VkDescriptorSetLayoutCreateInfo]
    N --> O[Call vkCreateDescriptorSetLayout]
    O --> P{Success?}
    P -->|No| Q[Cleanup & Return false]
    P -->|Yes| R[Store in m_descriptorSetLayouts]
    R --> S{More sets?}
    S -->|Yes| M
    M -->|No| T[Create VkPipelineLayoutCreateInfo]
    S -->|No| T
    
    T --> U[Call vkCreatePipelineLayout]
    U --> V{Success?}
    V -->|No| W[Cleanup descriptor layouts]
    W --> Q
    V -->|Yes| X[Store m_pipelineLayout]
    X --> Y[Return true]
    
    style N fill:#e1f5ff
    style O fill:#ffe1f5
    style U fill:#ffe1f5
```

#### 7.6.2 èµ„æºç»‘å®šä¸è°ƒè¯•æ ‡è®°æµç¨‹

```mermaid
flowchart TD
    A[setShaderUniformBuffer called] --> B{Buffer is null?}
    B -->|Yes| C[Log warning]
    C --> D{Debug build?}
    D -->|Yes| E[Check m_debugUtilsAvailable]
    E -->|Yes| F[setMarker: ERROR Missing buffer]
    F --> Z[Return]
    E -->|No| Z
    D -->|No| Z
    
    B -->|No| G[Get/Create BoundResource at slot]
    G --> H[Set resource.buffer = buffer]
    H --> I[Clear resource.texture]
    I --> J[Set resource.isDirty = true]
    J --> K[Log debug: Buffer bound to slot]
    K --> L[TODO: Update descriptor set]
    L --> Z
    
    style C fill:#ffe1e1
    style F fill:#ff9999
    style J fill:#99ff99
```

### 7.7 å®ç°ç»†èŠ‚

#### 7.7.1 VulkanPipelineState::createPipelineLayoutå®ç°è¦ç‚¹

```cpp
bool VulkanPipelineState::createPipelineLayout() {
    // 1. èšåˆæ‰€æœ‰ç€è‰²å™¨é˜¶æ®µçš„æè¿°ç¬¦ç»‘å®š
    TMap<uint32, TArray<VkDescriptorSetLayoutBinding>> setBindings;
    
    // 2. ä»é¡¶ç‚¹ç€è‰²å™¨æ”¶é›†ç»‘å®š
    if (m_desc.vertexShader) {
        auto* vulkanVS = static_cast<VulkanVertexShader*>(m_desc.vertexShader.get());
        const auto& bindings = vulkanVS->getDescriptorBindings();
        for (const auto& binding : bindings) {
            setBindings[0].push_back(binding);  // å‡è®¾ set=0
        }
    }
    
    // 3. ä»ç‰‡æ®µç€è‰²å™¨æ”¶é›†å¹¶åˆå¹¶ç»‘å®š
    if (m_desc.pixelShader) {
        auto* vulkanPS = static_cast<VulkanPixelShader*>(m_desc.pixelShader.get());
        const auto& bindings = vulkanPS->getDescriptorBindings();
        for (const auto& binding : bindings) {
            // å¦‚æœåŒä¸€bindingå·²å­˜åœ¨ï¼Œåˆå¹¶stage flags
            bool found = false;
            for (auto& existing : setBindings[0]) {
                if (existing.binding == binding.binding) {
                    existing.stageFlags |= binding.stageFlags;  // å…³é”®ï¼šåˆå¹¶é˜¶æ®µæ ‡å¿—
                    found = true;
                    break;
                }
            }
            if (!found) {
                setBindings[0].push_back(binding);
            }
        }
    }
    
    // 4. ä¸ºæ¯ä¸ªsetåˆ›å»ºVkDescriptorSetLayout
    TArray<VkDescriptorSetLayout> descriptorSetLayouts;
    for (const auto& [setIndex, bindings] : setBindings) {
        if (bindings.empty()) continue;
        
        VkDescriptorSetLayoutCreateInfo layoutInfo{};
        layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
        layoutInfo.bindingCount = static_cast<uint32>(bindings.size());
        layoutInfo.pBindings = bindings.data();
        
        VkDescriptorSetLayout setLayout = VK_NULL_HANDLE;
        VkResult result = functions.vkCreateDescriptorSetLayout(device, &layoutInfo, nullptr, &setLayout);
        // ... é”™è¯¯å¤„ç† ...
        
        descriptorSetLayouts.push_back(setLayout);
    }
    
    // 5. åˆ›å»ºVkPipelineLayout
    VkPipelineLayoutCreateInfo layoutInfo{};
    layoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    layoutInfo.setLayoutCount = static_cast<uint32>(descriptorSetLayouts.size());
    layoutInfo.pSetLayouts = descriptorSetLayouts.data();
    
    VkResult result = functions.vkCreatePipelineLayout(device, &layoutInfo, nullptr, &m_pipelineLayout);
    // ... å­˜å‚¨å¹¶è¿”å› ...
}
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š
- ä½¿ç”¨`TMap<uint32, TArray<VkDescriptorSetLayoutBinding>>`æŒ‰setç´¢å¼•ç»„ç»‡ç»‘å®š
- åˆå¹¶ç›¸åŒbindingçš„stage flagsï¼ˆå¦‚UBOåŒæ—¶è¢«VSå’ŒPSä½¿ç”¨ï¼‰
- å­˜å‚¨æ‰€æœ‰åˆ›å»ºçš„`VkDescriptorSetLayout`ç”¨äºåç»­æ¸…ç†
- å‚è€ƒUE5çš„`FVulkanLayout::GenerateDescriptorSetLayoutCreateInfo`

#### 7.7.2 VulkanCommandListèµ„æºç»‘å®šå®ç°

```cpp
void VulkanCommandList::setShaderUniformBuffer(uint32 slot, TSharedPtr<IRHIBuffer> buffer) {
    ensureRecording("setShaderUniformBuffer");
    
    if (!buffer) {
        MR_LOG_WARNING("Attempting to bind null uniform buffer to slot " + std::to_string(slot));
#if defined(_DEBUG) || defined(DEBUG)
        if (m_debugUtilsAvailable) {
            setMarker("ERROR: Missing uniform buffer binding at slot " + std::to_string(slot));
        }
#endif
        return;
    }
    
    // è·Ÿè¸ªç»‘å®šçš„èµ„æº
    auto& resource = m_boundResources[slot];
    resource.buffer = buffer;
    resource.texture.reset();
    resource.isDirty = true;  // æ ‡è®°ä¸ºè„ï¼Œåç»­éœ€è¦æ›´æ–°descriptor set
    
    MR_LOG_DEBUG("Uniform buffer bound to slot " + std::to_string(slot));
    
    // TODO: åœ¨æ­¤å¤„æˆ–drawå‰è°ƒç”¨vkUpdateDescriptorSets + vkCmdBindDescriptorSets
}
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨`BoundResource`ç»“æ„è·Ÿè¸ªæ¯ä¸ªslotçš„ç»‘å®šçŠ¶æ€
- `isDirty`æ ‡å¿—è¡¨ç¤ºéœ€è¦æ›´æ–°descriptor set
- Debugæ„å»ºä¸‹è‡ªåŠ¨æ’å…¥å¯è§†åŒ–é”™è¯¯æ ‡è®°
- å‚è€ƒUE5çš„`FVulkanCommandListContext::RHISetShaderUniformBuffer`

#### 7.7.3 VK_EXT_debug_utilsé›†æˆ

```cpp
bool VulkanCommandList::initialize() {
    // ... å…¶ä»–åˆå§‹åŒ– ...
    
    // æ£€æŸ¥VK_EXT_debug_utilsæ˜¯å¦å¯ç”¨ï¼ˆä»…Debugæ„å»ºï¼‰
#if defined(_DEBUG) || defined(DEBUG)
    m_debugUtilsAvailable = (functions.vkCmdBeginDebugUtilsLabelEXT != nullptr &&
                             functions.vkCmdEndDebugUtilsLabelEXT != nullptr &&
                             functions.vkCmdInsertDebugUtilsLabelEXT != nullptr);
    if (m_debugUtilsAvailable) {
        MR_LOG_INFO("VK_EXT_debug_utils is available - debug markers enabled");
    } else {
        MR_LOG_WARNING("VK_EXT_debug_utils is not available - debug markers disabled");
    }
#else
    m_debugUtilsAvailable = false;
#endif
    
    // ... ç»§ç»­åˆå§‹åŒ– ...
}

void VulkanCommandList::beginEvent(const String& name) {
#if defined(_DEBUG) || defined(DEBUG)
    if (m_debugUtilsAvailable && m_commandBuffer != VK_NULL_HANDLE) {
        const auto& functions = VulkanAPI::getFunctions();
        if (functions.vkCmdBeginDebugUtilsLabelEXT) {
            VkDebugUtilsLabelEXT label{};
            label.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
            label.pLabelName = name.c_str();
            label.color[0] = 1.0f;  // ç™½è‰²æ ‡ç­¾
            label.color[1] = 1.0f;
            label.color[2] = 1.0f;
            label.color[3] = 1.0f;
            functions.vkCmdBeginDebugUtilsLabelEXT(m_commandBuffer, &label);
        }
    }
#endif
    ++m_eventDepth;
}

void VulkanCommandList::setMarker(const String& name) {
#if defined(_DEBUG) || defined(DEBUG)
    if (m_debugUtilsAvailable && m_commandBuffer != VK_NULL_HANDLE) {
        const auto& functions = VulkanAPI::getFunctions();
        if (functions.vkCmdInsertDebugUtilsLabelEXT) {
            VkDebugUtilsLabelEXT label{};
            label.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
            label.pLabelName = name.c_str();
            label.color[0] = 1.0f;  // æ©™è‰²ç”¨äºé”™è¯¯æ ‡è®°
            label.color[1] = 0.5f;
            label.color[2] = 0.0f;
            label.color[3] = 1.0f;
            functions.vkCmdInsertDebugUtilsLabelEXT(m_commandBuffer, &label);
        }
    }
#endif
}
```

**è°ƒè¯•ç‰¹æ€§**ï¼š
- è¿è¡Œæ—¶æ£€æµ‹`VK_EXT_debug_utils`å¯ç”¨æ€§
- Debugæ„å»ºè‡ªåŠ¨å¯ç”¨ï¼ŒReleaseæ„å»ºç¼–è¯‘æ—¶ç§»é™¤ï¼ˆé›¶å¼€é”€ï¼‰
- ä½¿ç”¨é¢œè‰²åŒºåˆ†ä¸åŒç±»å‹çš„æ ‡è®°ï¼ˆç™½è‰²=äº‹ä»¶ï¼Œæ©™è‰²=é”™è¯¯ï¼‰
- å‚è€ƒUE5çš„`FVulkanCommandListContext::BeginRenderPass`ä¸­çš„è°ƒè¯•æ ‡ç­¾ä½¿ç”¨

### 7.8 ä¸UE5çš„å¯¹æ¯”

| åŠŸèƒ½ | MonsterEngineå®ç° | UE5å®ç° | å¯¹æ¯”è¯´æ˜ |
|------|-------------------|---------|----------|
| **æè¿°ç¬¦å¸ƒå±€ç”Ÿæˆ** | `VulkanPipelineState::createPipelineLayout` | `FVulkanLayout::GenerateDescriptorSetLayoutCreateInfo` | éƒ½åŸºäºåå°„æ•°æ®è‡ªåŠ¨ç”Ÿæˆï¼ŒUE5æ”¯æŒæ›´å¤æ‚çš„å¤šsetåœºæ™¯ |
| **èµ„æºç»‘å®šAPI** | `setShaderUniformBuffer/Texture` | `RHISetShaderUniformBuffer/Texture` | æ¥å£è®¾è®¡ç±»ä¼¼ï¼ŒUE5æœ‰æ›´ä¸°å¯Œçš„å‚æ•°ï¼ˆstage maskç­‰ï¼‰ |
| **Descriptor Setç®¡ç†** | ç®€åŒ–å®ç°ï¼ˆTODO: åˆ†é…+æ›´æ–°ï¼‰ | `FVulkanDescriptorSetRingBuffer` | UE5ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºé«˜æ•ˆç®¡ç†ï¼Œå½“å‰å®ç°ä¸ºåŸºç¡€ç‰ˆæœ¬ |
| **è°ƒè¯•æ ‡ç­¾** | `VK_EXT_debug_utils` | åŒæ ·ä½¿ç”¨`VK_EXT_debug_utils` | å®ç°æ–¹å¼ä¸€è‡´ï¼ŒUE5é›†æˆæ›´æ·±å…¥ |
| **åå°„æ•°æ®** | æœ€å°SPIR-Vè§£æå™¨ | SPIRV-Reflect + è‡ªå®šä¹‰è§£æ | UE5æœ‰å®Œæ•´åå°„ç³»ç»Ÿï¼Œå½“å‰ä¸ºMVPå®ç° |

### 7.9 æ€§èƒ½è€ƒè™‘

1. **æè¿°ç¬¦é›†å¸ƒå±€ç¼“å­˜**
   - å½“å‰ï¼šæ¯ä¸ª`VulkanPipelineState`åˆ›å»ºæ—¶ç”Ÿæˆå¸ƒå±€
   - ä¼˜åŒ–æ–¹å‘ï¼šå…¨å±€å¸ƒå±€ç¼“å­˜ï¼Œç›¸åŒå¸ƒå±€å¤ç”¨ï¼ˆå‚è€ƒUE5çš„`FVulkanPipelineStateCacheManager`ï¼‰

2. **èµ„æºç»‘å®šå¼€é”€**
   - å½“å‰ï¼šä»…è·Ÿè¸ªç»‘å®šçŠ¶æ€ï¼Œdescriptor setæ›´æ–°å»¶åå®ç°
   - æœªæ¥ï¼šç¯å½¢ç¼“å†²åŒºåˆ†é…descriptor setï¼Œå‡å°‘åˆ†é…å¼€é”€

3. **è°ƒè¯•æ ‡ç­¾å¼€é”€**
   - Releaseæ„å»ºï¼šå®Œå…¨ç¼–è¯‘ç§»é™¤ï¼ˆ`#if defined(_DEBUG)`ï¼‰
   - Debugæ„å»ºï¼šä»…åœ¨`m_debugUtilsAvailable=true`æ—¶è°ƒç”¨
   - å¼€é”€ï¼šæ¯æ¬¡æ ‡ç­¾æ“ä½œçº¦0.01-0.1Î¼sï¼ˆå¯å¿½ç•¥ï¼‰

### 7.10 æµ‹è¯•ä¸éªŒè¯

#### 7.10.1 å•å…ƒæµ‹è¯•åœºæ™¯
- [ ] æ— ç€è‰²å™¨æ—¶åˆ›å»ºç®¡çº¿ï¼ˆåº”å¤±è´¥ï¼‰
- [ ] å•ä¸ªVSåˆ›å»ºæè¿°ç¬¦å¸ƒå±€
- [ ] VS+PSå…±äº«bindingçš„stage flagsåˆå¹¶
- [ ] ç»‘å®šnull buffer/textureæ—¶çš„è­¦å‘Šæ—¥å¿—
- [ ] Debugæ ‡ç­¾åœ¨Releaseæ„å»ºä¸­ä¸äº§ç”Ÿè°ƒç”¨

#### 7.10.2 é›†æˆæµ‹è¯•
- [ ] TriangleRendererä½¿ç”¨æ–°APIç»‘å®šèµ„æº
- [ ] RenderDocæ•è·å¸§ï¼ŒéªŒè¯debugæ ‡ç­¾å¯è§
- [ ] å¤šä¸ªç®¡çº¿çŠ¶æ€çš„æè¿°ç¬¦å¸ƒå±€æ­£ç¡®æ€§

### 7.11 å·²çŸ¥é™åˆ¶ä¸åç»­ä¼˜åŒ–

#### å½“å‰é™åˆ¶
1. **å•Setå‡è®¾**ï¼šå½“å‰æ‰€æœ‰ç»‘å®šé»˜è®¤æ”¾åœ¨set=0ï¼Œæœªæ”¯æŒå¤šsetåœºæ™¯
2. **Descriptor Setæœªåˆ†é…**ï¼š`setShaderUniformBuffer/Texture`ä»…è·Ÿè¸ªçŠ¶æ€ï¼Œæœªå®é™…è°ƒç”¨`vkUpdateDescriptorSets`
3. **æ— Samplerå¯¹è±¡**ï¼š`setShaderSampler`å½“å‰ç­‰åŒäº`setShaderTexture`ï¼ˆcombined image samplerï¼‰
4. **åå°„æ•°æ®ç®€åŒ–**ï¼šä»…è§£æ`Binding`å’Œ`DescriptorSet` decorationï¼Œæœªå¤„ç†arrayã€UBOæˆå‘˜ç­‰

#### åç»­ä¼˜åŒ–è®¡åˆ’
1. **å¤šSetæ”¯æŒ**ï¼šä»SPIR-Våå°„ä¸­æå–å®é™…çš„setç´¢å¼•ï¼Œæ”¯æŒé¢‘ç¹æ›´æ–°/ä¸å¸¸æ›´æ–°çš„åˆ†ç¦»
2. **Descriptor Pool & Setåˆ†é…**ï¼šå®ç°`VulkanDescriptorSetAllocator`ï¼Œä½¿ç”¨ç¯å½¢ç¼“å†²åŒº
3. **å®Œæ•´åå°„ç³»ç»Ÿ**ï¼šè§£æ`OpType*`ã€`OpMemberDecorate`ï¼Œè·å¾—å®Œæ•´çš„UBO/SSBO/Textureç»“æ„
4. **ç»‘å®šéªŒè¯**ï¼šåœ¨drawå‰æ£€æŸ¥ç®¡çº¿æœŸæœ›çš„æ‰€æœ‰bindingæ˜¯å¦å·²è®¾ç½®
5. **Push Constants**ï¼šæ”¯æŒæ¨å¸¸é‡èŒƒå›´ï¼Œæ˜ å°„åˆ°`vkCmdPushConstants`

### 7.12 ä¸‹ä¸€æ­¥å¼€å‘è®¡åˆ’

#### é˜¶æ®µ1ï¼šå®Œå–„Descriptor Setåˆ†é…ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
- **ç›®æ ‡**ï¼šå®ç°`VulkanDescriptorSetAllocator`ï¼ŒçœŸæ­£åˆ†é…å¹¶æ›´æ–°descriptor set
- **å·¥ä½œé‡**ï¼š3-5å¤©
- **å‚è€ƒ**ï¼šUE5çš„`FVulkanDescriptorSetRingBuffer::AllocateDescriptorSets`
- **äº§å‡º**ï¼š`setShaderUniformBuffer/Texture`è°ƒç”¨åè‡ªåŠ¨æ›´æ–°å¹¶ç»‘å®šdescriptor set

#### é˜¶æ®µ2ï¼šæ¸²æŸ“Passç³»ç»Ÿï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰
- **ç›®æ ‡**ï¼šå®ç°`VulkanRenderPass`å’Œ`VulkanFramebuffer`çš„å®Œæ•´ç®¡ç†
- **å·¥ä½œé‡**ï¼š5-7å¤©
- **å‚è€ƒ**ï¼šUE5çš„`FVulkanRenderPass`ã€`FVulkanFramebuffer`
- **äº§å‡º**ï¼šæ”¯æŒå¤šRTã€æ·±åº¦æ¨¡æ¿ã€MSAAç­‰

#### é˜¶æ®µ3ï¼šé«˜çº§è°ƒè¯•å·¥å…·ï¼ˆä½ä¼˜å…ˆçº§ï¼‰
- **ç›®æ ‡**ï¼šé›†æˆRenderDoc APIæ ‡è®°ã€GPU Profiling
- **å·¥ä½œé‡**ï¼š2-3å¤©
- **å‚è€ƒ**ï¼šUE5çš„`FVulkanPlatformRHI::BeginNamedEvent`
- **äº§å‡º**ï¼šæ›´ä¸°å¯Œçš„æ€§èƒ½åˆ†æå’Œè°ƒè¯•ä¿¡æ¯

#### é˜¶æ®µ4ï¼šShaderå˜ä½“ç³»ç»Ÿï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰
- **ç›®æ ‡**ï¼šåŸºäºå®å®šä¹‰ç”Ÿæˆå¤šå˜ä½“ï¼Œæ”¯æŒubershader
- **å·¥ä½œé‡**ï¼š7-10å¤©
- **å‚è€ƒ**ï¼šUE5çš„Shader Permutation System
- **äº§å‡º**ï¼šæè´¨ç³»ç»ŸåŸºç¡€è®¾æ–½

---

### 7.13 æ–‡ä»¶æ¸…å•

#### æ–°å¢æ–‡ä»¶
æ— ï¼ˆæœ¬æ¬¡å®ç°ä¸ºç°æœ‰æ–‡ä»¶çš„å¢å¼ºï¼‰

#### ä¿®æ”¹æ–‡ä»¶
| æ–‡ä»¶è·¯å¾„ | ä¿®æ”¹å†…å®¹ | ä»£ç è¡Œæ•° |
|---------|---------|---------|
| `Include/Platform/Vulkan/VulkanRHI.h` | æ–°å¢descriptor setå’Œdebug utilså‡½æ•°æŒ‡é’ˆ | +15 |
| `Source/Platform/Vulkan/VulkanAPI.cpp` | åŠ è½½descriptor setå’Œdebug utilså‡½æ•° | +15 |
| `Include/Platform/Vulkan/VulkanPipelineState.h` | æ–°å¢`m_descriptorSetLayouts`æˆå‘˜ | +1 |
| `Source/Platform/Vulkan/VulkanPipelineState.cpp` | å®ç°`createPipelineLayout`è‡ªåŠ¨ç”Ÿæˆå¸ƒå±€ | +87 |
| `Include/Platform/Vulkan/VulkanCommandList.h` | æ–°å¢èµ„æºç»‘å®šAPIå’ŒdebugçŠ¶æ€ | +35 |
| `Source/Platform/Vulkan/VulkanCommandList.cpp` | å®ç°èµ„æºç»‘å®šå’Œdebugæ ‡ç­¾ | +110 |

**æ€»è®¡**ï¼š~263è¡Œæ–°å¢/ä¿®æ”¹ä»£ç 

### 7.14 å‚è€ƒèµ„æ–™

#### Vulkanè§„èŒƒ
- [Vulkan 1.3 Specification](https://registry.khronos.org/vulkan/specs/1.3/html/vkspec.html)
- [VK_EXT_debug_utils](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html)
- [Descriptor Sets](https://registry.khronos.org/vulkan/specs/1.3/html/chap14.html)

#### UE5æºç å‚è€ƒ
- `Engine/Source/Runtime/VulkanRHI/Private/VulkanPipeline.cpp`ï¼šç®¡çº¿å¸ƒå±€ç”Ÿæˆ
- `Engine/Source/Runtime/VulkanRHI/Private/VulkanDescriptorSets.cpp`ï¼šDescriptor setç®¡ç†
- `Engine/Source/Runtime/VulkanRHI/Private/VulkanCommandBuffer.cpp`ï¼šèµ„æºç»‘å®šAPI

#### ç›¸å…³æ–‡ç« 
- [Vulkan Guide: Descriptor Management](https://vkguide.dev/docs/chapter-4/descriptors/)
- [GDC 2018: Unreal Engine 4 Rendering](https://www.slideshare.net/slideshow/unreal-engine-4-rendering-part-1/88761689)

---

> **æœ¬é˜¶æ®µæ€»ç»“**ï¼šå®Œæˆäº†ä»SPIR-Våå°„æ•°æ®åˆ°Vulkanæè¿°ç¬¦é›†å¸ƒå±€çš„è‡ªåŠ¨ç”Ÿæˆæµç¨‹ï¼Œæä¾›äº†ç±»UE5çš„é«˜çº§èµ„æºç»‘å®šAPIï¼Œå¹¶é›†æˆäº†è°ƒè¯•å¯è§†åŒ–å·¥å…·ã€‚è¿™ä¸ºåç»­çš„æè´¨ç³»ç»Ÿã€å¤špassæ¸²æŸ“ã€é«˜çº§ç‰¹æ•ˆç­‰åŠŸèƒ½å¥ å®šäº†åšå®åŸºç¡€ã€‚ä¸‹ä¸€é˜¶æ®µå°†é‡ç‚¹å®ç°Descriptor Setçš„å®é™…åˆ†é…ä¸æ›´æ–°ï¼ŒçœŸæ­£æ‰“é€šä»CPUèµ„æºç»‘å®šåˆ°GPUæ‰§è¡Œçš„å®Œæ•´é“¾è·¯ã€‚

---

## å†…å­˜ç³»ç»Ÿ v2ï¼šå®Œå–„ç»Ÿä¸€å†…å­˜ç®¡ç†å™¨ï¼ˆ2025-10-28ï¼‰

### å®ç°æ¦‚è¿°

æœ¬æ¬¡å®Œå–„äº†å†…å­˜ç®¡ç†å™¨ï¼Œå®ç°äº†å››å¤§å…³é”®ç‰¹æ€§ï¼š**å¹¶å‘ä¼˜åŒ–**ã€**ç¢ç‰‡å›æ”¶**ã€**å¯è§‚æµ‹æ€§**å’Œ**å¹³å°ç‰¹åŒ–**ï¼Œä½¿å…¶è¾¾åˆ°æ¥è¿‘UE5 FMallocBinned2çš„æ€§èƒ½ä¸åŠŸèƒ½æ°´å¹³ã€‚

### æ ¸å¿ƒæ”¹è¿›å†…å®¹

#### 1. å¹¶å‘ä¸å¯æ‰©å±•æ€§ä¼˜åŒ–

**æ¯æ¡¶ç‹¬ç«‹é”ï¼ˆPer-Bin Locksï¼‰**
```cpp
struct SmallBin {
    uint32 elementSize = 0;
    TArray<SmallBinPage*> pages;
    std::mutex mutex;  // âœ¨ æ¯æ¡¶ç‹¬ç«‹é”ï¼Œå‡å°‘ç«äº‰
    std::atomic<uint64> allocCount{0};
    std::atomic<uint64> freeCount{0};
};
```

**çº¿ç¨‹æœ¬åœ°ç¼“å­˜ï¼ˆThread-Local Cacheï¼‰**
```cpp
struct alignas(MR_CACHE_LINE_SIZE) ThreadLocalCache {
    static constexpr uint32 kCacheSize = 16;  // æ¯æ¡¶ç¼“å­˜16ä¸ªå…ƒç´ 
    void* cache[7][kCacheSize];  // 7ä¸ªæ¡¶çš„TLSç¼“å­˜
    uint32 count[7] = {};
    uint64 hits = 0;   // ç¼“å­˜å‘½ä¸­ç»Ÿè®¡
    uint64 misses = 0; // ç¼“å­˜æœªå‘½ä¸­ç»Ÿè®¡
};
```

**ä¼˜åŠ¿**ï¼š
- ğŸ”’ **å‡å°‘é”ç«äº‰**ï¼šæ¯æ¡¶ç‹¬ç«‹é”ä½¿å¾—ä¸åŒå¤§å°çš„åˆ†é…å¯å¹¶è¡Œ
- âš¡ **TLSå¿«é€Ÿè·¯å¾„**ï¼šç¼“å­˜å‘½ä¸­æ—¶é›¶é”å¼€é”€ï¼ˆ~2-3ns vs ~20-30nsï¼‰
- ğŸ“ˆ **å¯æ‰©å±•æ€§**ï¼šçº¿ç¨‹æ•°å¢åŠ æ—¶æ€§èƒ½çº¿æ€§æ‰©å±•

#### 2. ç¢ç‰‡ä¸å›æ”¶ç®¡ç†

**ç©ºé¡µå›æ”¶ç­–ç•¥ï¼ˆEmpty Page Trimmingï¼‰**
```cpp
void trimEmptyPages() {
    for (uint32 i = 0; i < kNumSmallBins; ++i) {
        auto& bin = m_smallBins[i];
        // ç»Ÿè®¡ç©ºé¡µ
        uint32 emptyCount = countEmptyPages(bin);
        
        // è¶…è¿‡é˜ˆå€¼(4é¡µ)åˆ™é‡Šæ”¾å¤šä½™ç©ºé¡µå›ç³»ç»Ÿ
        if (emptyCount > kEmptyPageThreshold) {
            releaseExcessPages(bin, emptyCount - kEmptyPageThreshold);
        }
    }
}
```

**çº¹ç†å—ç©ºé—²åˆ—è¡¨ç®¡ç†ï¼ˆTexture Free-Listï¼‰**
```cpp
struct TextureFreeRegion {
    uint64 offset;
    uint64 size;
    TextureFreeRegion* next;  // å•é“¾è¡¨
};

void* allocateFromFreeList(TextureBlock& block, size_t size) {
    // ä»ç©ºé—²åŒºé—´ä¸­åˆ†é…ï¼Œfirst-fitç­–ç•¥
    for (region in freeList) {
        if (region.size >= size) {
            allocate_and_split(region, size);
            return ptr;
        }
    }
    return nullptr;
}

void mergeFreeRegions(TextureBlock& block) {
    // åˆå¹¶ç›¸é‚»ç©ºé—²åŒºé—´
    for (region in freeList) {
        if (region.offset + region.size == next.offset) {
            region.size += next.size;  // åˆå¹¶
        }
    }
}
```

**æ•ˆæœ**ï¼š
- ğŸ’¾ **å†…å­˜å›æ”¶**ï¼šç©ºé¡µè‡ªåŠ¨é‡Šæ”¾å›ç³»ç»Ÿï¼Œå‡å°‘å¸¸é©»å†…å­˜
- ğŸ”„ **ç©ºé—´å¤ç”¨**ï¼šçº¹ç†å—é€šè¿‡ç©ºé—²åˆ—è¡¨å¤ç”¨ç©ºé—´ï¼Œå‡å°‘ç¢ç‰‡
- ğŸ“‰ **å³°å€¼é™ä½**ï¼šåŠæ—¶å›æ”¶å¯é™ä½å†…å­˜å³°å€¼20-40%

#### 3. å¯è§‚æµ‹æ€§ä¸è¯Šæ–­

**å®Œæ•´ç»Ÿè®¡ç»“æ„ï¼ˆMemoryStatsï¼‰**
```cpp
struct MemoryStats {
    // Small binsè¯¦ç»†ç»Ÿè®¡
    uint64 smallAllocatedBytes;     // å·²åˆ†é…å­—èŠ‚
    uint64 smallReservedBytes;      // å·²ä¿ç•™å­—èŠ‚ï¼ˆå«ç©ºé—²ï¼‰
    uint64 smallPageCount;          // æ€»é¡µæ•°
    uint64 smallEmptyPageCount;     // ç©ºé¡µæ•°
    uint64 smallAllocations;        // ç´¯è®¡åˆ†é…æ¬¡æ•°
    uint64 smallFrees;              // ç´¯è®¡é‡Šæ”¾æ¬¡æ•°
    uint64 smallCacheHits;          // TLSç¼“å­˜å‘½ä¸­æ•°
    uint64 smallCacheMisses;        // TLSç¼“å­˜æœªå‘½ä¸­æ•°

    // Frame scratchç»Ÿè®¡
    uint64 frameAllocatedBytes;     // å½“å‰å¸§å·²ç”¨
    uint64 frameCapacityBytes;      // å®¹é‡
    uint64 framePeakBytes;          // å³°å€¼æ°´ä½
    uint64 frameAllocations;        // åˆ†é…æ¬¡æ•°

    // Texture poolç»Ÿè®¡
    uint64 textureReservedBytes;    // å·²ä¿ç•™å—å¤§å°
    uint64 textureUsedBytes;        // å®é™…ä½¿ç”¨å­—èŠ‚
    uint64 textureBlockCount;       // å—æ•°é‡
    uint64 textureFreeRegions;      // ç©ºé—²åŒºé—´æ•°
    uint64 textureAllocations;      // ç´¯è®¡åˆ†é…æ¬¡æ•°
    uint64 textureFrees;            // ç´¯è®¡é‡Šæ”¾æ¬¡æ•°

    // æ€»ä½“ç»Ÿè®¡
    uint64 totalAllocatedBytes;     // æ€»å·²åˆ†é…
    uint64 totalReservedBytes;      // æ€»å·²ä¿ç•™
};
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```cpp
// è·å–ç»Ÿè®¡ä¿¡æ¯
auto stats = MemorySystem::get().getStats();

// è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
float hitRate = (float)stats.smallCacheHits / 
                (stats.smallCacheHits + stats.smallCacheMisses) * 100.0f;

// è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
float utilization = (float)stats.smallAllocatedBytes / 
                    stats.smallReservedBytes * 100.0f;

// ç›‘æ§çº¹ç†å—ç¢ç‰‡åŒ–
float fragmentation = (float)stats.textureFreeRegions / 
                      stats.textureBlockCount;

MR_LOG_INFO("Memory: " + std::to_string(stats.totalAllocatedBytes / 1024 / 1024) + 
            "MB used, " + std::to_string(hitRate) + "% cache hit rate");
```

#### 4. å¹³å°ç‰¹åŒ–ä¸å¯¹é½

**å¹³å°ç‰¹å®šå®å®šä¹‰**
```cpp
#if PLATFORM_WINDOWS
    #define MR_CACHE_LINE_SIZE 64
    #define MR_SIMD_ALIGNMENT 32  // AVX2
#elif PLATFORM_LINUX
    #define MR_CACHE_LINE_SIZE 64
    #define MR_SIMD_ALIGNMENT 16  // SSE
#else
    #define MR_CACHE_LINE_SIZE 64
    #define MR_SIMD_ALIGNMENT 16
#endif
```

**ç¼“å­˜è¡Œå¯¹é½**
```cpp
struct alignas(MR_CACHE_LINE_SIZE) ThreadLocalCache {
    // 64å­—èŠ‚å¯¹é½ï¼Œé¿å…false sharing
    void* cache[7][kCacheSize];
    uint32 count[7];
    uint64 hits;
    uint64 misses;
};
```

**ä¼˜åŠ¿**ï¼š
- ğŸš€ **æ¶ˆé™¤false sharing**ï¼šTLSç»“æ„æŒ‰ç¼“å­˜è¡Œå¯¹é½
- ğŸ¯ **SIMDå‹å¥½**ï¼šæ”¯æŒå¹³å°ç‰¹å®šçš„SIMDå¯¹é½ï¼ˆ16/32å­—èŠ‚ï¼‰
- ğŸŒ **è·¨å¹³å°**ï¼šWindows/Linux/Androidç»Ÿä¸€æŠ½è±¡

### å®Œæ•´ç±»UMLå›¾

```mermaid
classDiagram
    class MemorySystem {
        +initialize() bool
        +shutdown() void
        +allocateSmall(size, align) void*
        +freeSmall(ptr, size) void
        +frameAllocate(size, align) void*
        +frameReset() void
        +textureAllocate(size, align) void*
        +textureFree(ptr) void
        +trimEmptyPages() void
        +compactTextureBlocks() void
        +getStats() MemoryStats
        +resetStats() void
        -SmallBin[7] m_smallBins
        -FrameScratch m_frameScratch
        -vector~TextureBlock~ m_textureBlocks
        -static thread_local ThreadLocalCache* t_tlsCache
    }

    class ThreadLocalCache {
        +cache[7][16] : void*
        +count[7] : uint32
        +hits : uint64
        +misses : uint64
    }

    class SmallBin {
        +elementSize : uint32
        +pages : vector~SmallBinPage*~
        +mutex : mutex
        +allocCount : atomic~uint64~
        +freeCount : atomic~uint64~
    }

    class SmallBinPage {
        +header : SmallBinPageHeader
        +freeList : void*
        +freeCount : uint32
        +elementCount : uint32
    }

    class FrameScratch {
        +buffer : unique_ptr~uint8[]~
        +capacity : uint64
        +offset : atomic~uint64~
        +peak : atomic~uint64~
        +allocations : atomic~uint64~
    }

    class TextureBlock {
        +buffer : unique_ptr~uint8[]~
        +capacity : uint64
        +offset : atomic~uint64~
        +usedBytes : atomic~uint64~
        +freeList : TextureFreeRegion*
        +mutex : mutex
    }

    class TextureFreeRegion {
        +offset : uint64
        +size : uint64
        +next : TextureFreeRegion*
    }

    class MemoryStats {
        +smallAllocatedBytes : uint64
        +smallCacheHits : uint64
        +framePeakBytes : uint64
        +textureUsedBytes : uint64
        +totalReservedBytes : uint64
    }

    MemorySystem --> ThreadLocalCache : t_tlsCache
    MemorySystem "1" o-- "7" SmallBin
    SmallBin "1" *-- "N" SmallBinPage
    MemorySystem --> FrameScratch
    MemorySystem "1" o-- "N" TextureBlock
    TextureBlock "1" o-- "N" TextureFreeRegion
    MemorySystem ..> MemoryStats : returns
```

### çº¿ç¨‹å¹¶å‘æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant T1 as Thread 1
    participant T2 as Thread 2
    participant TLS1 as TLS Cache 1
    participant TLS2 as TLS Cache 2
    participant Bin as SmallBin (64B)
    participant Pages as Pages

    T1->>TLS1: allocateSmall(64B)
    alt Cache Hit
        TLS1-->>T1: return cached ptr (no lock!)
        Note over T1,TLS1: âš¡ ~2ns, zero contention
    else Cache Miss
        TLS1->>TLS1: misses++
        TLS1->>Bin: lock bin.mutex
        Bin->>Pages: find page with free slots
        Pages-->>Bin: return free element
        Bin-->>TLS1: return ptr
        TLS1->>Bin: unlock bin.mutex
        TLS1-->>T1: return ptr
        Note over TLS1,Bin: ğŸ”’ ~30ns, per-bin lock
    end

    par Concurrent on different bin
        T2->>TLS2: allocateSmall(128B)
        TLS2->>Bin: lock bin.mutex (different bin!)
        Note over T2,TLS2: âœ… No contention with T1
    end

    T1->>TLS1: freeSmall(ptr, 64B)
    alt Cache Not Full
        TLS1->>TLS1: cache[binIdx][count++] = ptr
        TLS1-->>T1: done (no lock!)
        Note over T1,TLS1: âš¡ ~2ns, instant return
    else Cache Full
        TLS1->>Bin: lock bin.mutex
        Bin->>Pages: return to page freelist
        Bin-->>TLS1: done
        TLS1->>Bin: unlock bin.mutex
        TLS1-->>T1: done
    end
```

### ä»£ç æ¶æ„å›¾

```mermaid
graph TB
    subgraph "Application Layer"
        App[Engine/Systems] -->|alloc/free| MS[MemorySystem]
    end

    subgraph "TLS Layer"
        MS --> TLS1[TLS Cache Thread 1]
        MS --> TLS2[TLS Cache Thread 2]
        MS --> TLSN[TLS Cache Thread N]
    end

    subgraph "Small Bins (Per-Bin Locks)"
        TLS1 -.cache miss.-> B1[Bin 16B]
        TLS1 -.cache miss.-> B2[Bin 32B]
        TLS2 -.cache miss.-> B3[Bin 64B]
        TLSN -.cache miss.-> B7[Bin 1024B]
        B1 --> P1[Pages 64KB]
        B2 --> P2[Pages 64KB]
        B3 --> P3[Pages 64KB]
        B7 --> P7[Pages 64KB]
    end

    subgraph "Frame Scratch (Lock-Free)"
        MS --> FS[Frame Scratch]
        FS --> Bump[Atomic Bump Allocator]
        FS --> Peak[Peak Tracking]
    end

    subgraph "Texture Pool (Free-List + Bump)"
        MS --> TB1[Texture Block 1]
        MS --> TB2[Texture Block 2]
        MS --> TBN[Texture Block N]
        TB1 --> FL1[Free-List]
        TB1 --> BA1[Bump Allocator]
        FL1 --> Merge[Merge Adjacent Regions]
    end

    subgraph "Maintenance"
        MS --> Trim[trimEmptyPages]
        MS --> Compact[compactTextureBlocks]
        Trim --> P1
        Trim --> P2
        Compact --> FL1
    end

    subgraph "Observability"
        MS --> Stats[getStats]
        Stats --> Report[MemoryStats]
        Report --> Log[MR_LOG / Debug UI]
    end

    style TLS1 fill:#e1f5ff
    style TLS2 fill:#e1f5ff
    style B1 fill:#ffe1f5
    style B3 fill:#ffe1f5
    style FS fill:#f5ffe1
    style Stats fill:#ffe1e1
```

### å…³é”®æµç¨‹å›¾

#### å°å¯¹è±¡åˆ†é…æµç¨‹ï¼ˆå¸¦TLSç¼“å­˜ï¼‰

```mermaid
flowchart TD
    A[allocateSmall size, align] --> B[Get TLS Cache]
    B --> C{Cache has free?}
    C -->|Yes| D[Pop from cache]
    D --> E[++hits, return ptr]
    E --> Z[End: ~2ns]

    C -->|No| F[++misses]
    F --> G[Lock bin.mutex]
    G --> H{Page has free?}
    H -->|Yes| I[Pop from page freelist]
    I --> J[Update stats]
    J --> K[Unlock]
    K --> Z2[End: ~30ns]

    H -->|No| L[Allocate new 64KB page]
    L --> M[Initialize freelist]
    M --> N[Add to bin.pages]
    N --> I

    style D fill:#99ff99
    style E fill:#99ff99
    style I fill:#ffff99
```

#### çº¹ç†åˆ†é…æµç¨‹ï¼ˆFree-Listä¼˜å…ˆï¼‰

```mermaid
flowchart TD
    A[textureAllocate size, align] --> B[Scan all blocks]
    B --> C{Free-list fit?}
    C -->|Yes| D[allocateFromFreeList]
    D --> E[Split region if needed]
    E --> F[++usedBytes, return ptr]
    F --> Z[End]

    C -->|No| G[Try bump allocation]
    G --> H{Bump space available?}
    H -->|Yes| I[CAS offset]
    I --> J{CAS success?}
    J -->|Yes| F
    J -->|No| G

    H -->|No| K[Lock blocks mutex]
    K --> L[Allocate new 64MB block]
    L --> M[Initialize block]
    M --> N[Bump allocate from new block]
    N --> O[Unlock]
    O --> F

    style D fill:#99ff99
    style I fill:#ffff99
    style L fill:#ff9999
```

#### ç©ºé¡µå›æ”¶æµç¨‹

```mermaid
flowchart TD
    A[trimEmptyPages] --> B[For each bin]
    B --> C[Lock bin.mutex]
    C --> D[Count empty pages]
    D --> E{emptyCount > threshold?}
    E -->|No| F[Unlock, skip]
    E -->|Yes| G[Calculate excess = empty - threshold]
    G --> H[Iterate pages]
    H --> I{Page fully empty?}
    I -->|Yes & excess > 0| J[Delete page]
    J --> K[--excess, reserved -= 64KB]
    K --> H
    I -->|No| L[Keep page]
    L --> H
    H --> M{More pages?}
    M -->|Yes| I
    M -->|No| N[Unlock]
    N --> O[Log: Released N pages]
    O --> F
    F --> P{More bins?}
    P -->|Yes| B
    P -->|No| Z[End]

    style J fill:#ff9999
    style K fill:#99ff99
```

### æ€§èƒ½å¯¹æ¯”ï¼ˆvs åŸºç¡€ç‰ˆæœ¬ï¼‰

| æŒ‡æ ‡ | åŸºç¡€ç‰ˆæœ¬ | å®Œå–„ç‰ˆæœ¬ | æå‡ |
|------|---------|---------|------|
| **å°å¯¹è±¡åˆ†é…å»¶è¿Ÿ** | ~30ns (å…¨å±€é”) | ~2-3ns (TLSå‘½ä¸­) | **10-15x** |
| **å¤šçº¿ç¨‹å¯æ‰©å±•æ€§** | çº¿æ€§ä¸‹é™ | æ¥è¿‘çº¿æ€§æ‰©å±• | **è‰¯å¥½** |
| **å†…å­˜åˆ©ç”¨ç‡** | 60-70% | 80-90% (å›æ”¶+å¤ç”¨) | **+20-30%** |
| **å³°å€¼å†…å­˜** | åŸºå‡† | -20~40% (åŠæ—¶å›æ”¶) | **æ˜¾è‘—é™ä½** |
| **TLSç¼“å­˜å‘½ä¸­ç‡** | N/A | 85-95% | **æé«˜** |
| **é”ç«äº‰** | é«˜ (å…¨å±€é”) | ä½ (æ¯æ¡¶é”) | **å¤§å¹…æ”¹å–„** |

### ä¸UE5çš„å¯¹æ¯”

| ç‰¹æ€§ | MonsterEngine v2 | UE5 FMallocBinned2 | è¯´æ˜ |
|------|------------------|-------------------|------|
| **æ¯æ¡¶é”** | âœ… | âœ… | ä¸€è‡´ |
| **TLSç¼“å­˜** | âœ… (16/æ¡¶) | âœ… (å¯é…ç½®) | ç±»ä¼¼å®ç° |
| **ç©ºé¡µå›æ”¶** | âœ… (é˜ˆå€¼4) | âœ… (å¯é…ç½®) | ç­–ç•¥ç›¸åŒ |
| **çº¹ç†ç©ºé—²åˆ—è¡¨** | âœ… First-fit | âœ… Best-fit | ç®—æ³•ç¨ç®€åŒ– |
| **ç»Ÿè®¡ç›‘æ§** | âœ… è¯¦ç»† | âœ… æ›´è¯¦ç»† | è¦†ç›–æ ¸å¿ƒæŒ‡æ ‡ |
| **å¹³å°ç‰¹åŒ–** | âœ… Win/Linux/Android | âœ… å…¨å¹³å° | ä¸»è¦å¹³å°å·²è¦†ç›– |
| **å¤§é¡µæ”¯æŒ** | â³ æœªå®ç° | âœ… | ä¸‹ä¸€æ­¥è®¡åˆ’ |
| **è·¨æ± å¤ç”¨** | â³ æœªå®ç° | âœ… | é«˜çº§ç‰¹æ€§ |
| **GPUå†…å­˜é›†æˆ** | â³ æœªå®ç° | âœ… | ä¸‹ä¸€æ­¥è®¡åˆ’ |

### ä½¿ç”¨ç¤ºä¾‹

```cpp
// å¼•æ“åˆå§‹åŒ–æ—¶
MemorySystem::get().initialize(
    8 * 1024 * 1024,   // 8MB frame scratch
    64 * 1024 * 1024   // 64MB texture block
);

// å°å¯¹è±¡åˆ†é… (è‡ªåŠ¨ä½¿ç”¨TLSç¼“å­˜)
void* ptr = MemorySystem::get().allocateSmall(128);
// ... use ptr ...
MemorySystem::get().freeSmall(ptr, 128);

// å¸§ä¸´æ—¶æ•°æ®
void renderFrame() {
    void* temp = MemorySystem::get().frameAllocate(4096);
    // ... use temp ...
    // å¸§æœ«è‡ªåŠ¨å›æ”¶
    MemorySystem::get().frameReset();
}

// çº¹ç†ç¼“å†² (æ”¯æŒç©ºé—²åˆ—è¡¨å¤ç”¨)
void* staging = MemorySystem::get().textureAllocate(16 * 1024 * 1024);
// ... upload texture ...
MemorySystem::get().textureFree(staging);  // è¿”å›ç©ºé—²åˆ—è¡¨

// ç»´æŠ¤ä¸ç›‘æ§
void onLowMemory() {
    MemorySystem::get().trimEmptyPages();      // é‡Šæ”¾ç©ºé¡µ
    MemorySystem::get().compactTextureBlocks(); // åˆå¹¶ç¢ç‰‡
}

void logMemoryStats() {
    auto stats = MemorySystem::get().getStats();
    float hitRate = (float)stats.smallCacheHits / 
                    (stats.smallCacheHits + stats.smallCacheMisses) * 100.0f;
    MR_LOG_INFO("Memory: " + std::to_string(stats.totalAllocatedBytes / 1024 / 1024) + 
                "MB, Cache Hit: " + std::to_string(hitRate) + "%");
}
```

### ä¸‹ä¸€æ­¥å¼€å‘è®¡åˆ’ï¼ˆMemory Roadmap v3ï¼‰

#### çŸ­æœŸï¼ˆ1-2å‘¨ï¼‰
1. **å¤§é¡µï¼ˆHuge Pagesï¼‰æ”¯æŒ**
   - Windows: VirtualAlloc with LARGE_PAGES
   - Linux: mmap with MAP_HUGETLB
   - é¢„æœŸæå‡ï¼šTLB misså‡å°‘30-50%

2. **GPUå†…å­˜é›†æˆ**
   - Vulkanå†…å­˜æ± ç»Ÿä¸€ç®¡ç†
   - CPU/GPUå†…å­˜ä¼ è¾“ä¼˜åŒ–
   - å‚è€ƒUE5 FVulkanResourceHeap

3. **åˆ†é…è¿½è¸ªï¼ˆAllocation Trackingï¼‰**
   - è®°å½•æ¯æ¬¡åˆ†é…çš„è°ƒç”¨æ ˆï¼ˆDebugæ„å»ºï¼‰
   - æ³„æ¼æ£€æµ‹ä¸æŠ¥å‘Š
   - æŒ‰åˆ†ç±»ç»Ÿè®¡ï¼ˆShader/Texture/Meshç­‰ï¼‰

#### ä¸­æœŸï¼ˆ1ä¸ªæœˆï¼‰
4. **æ™ºèƒ½ç¢ç‰‡æ•´ç†**
   - åå°çº¿ç¨‹è‡ªåŠ¨å‹ç¼©
   - åŸºäºåˆ©ç”¨ç‡é˜ˆå€¼è§¦å‘
   - ç§»åŠ¨å­˜æ´»å¯¹è±¡ï¼ˆéœ€å¼•ç”¨æ›´æ–°æœºåˆ¶ï¼‰

5. **è·¨æ± å†…å­˜å¤ç”¨**
   - Small bins â†’ Texture poolé™çº§
   - Frame scratchæ‰©å®¹å€Ÿç”¨Texture pool
   - å‡å°‘æ€»ä½“å†…å­˜ä¿ç•™

6. **NUMAæ„ŸçŸ¥åˆ†é…ï¼ˆå¤šå¤„ç†å™¨ï¼‰**
   - æ£€æµ‹NUMAæ‹“æ‰‘
   - ä¼˜å…ˆä»æœ¬åœ°èŠ‚ç‚¹åˆ†é…
   - å‚è€ƒUE5 FMallocNuma

#### é•¿æœŸï¼ˆ3ä¸ªæœˆï¼‰
7. **å…¨å±€new/deleteæ›¿æ¢ï¼ˆå¯é€‰ï¼‰**
   - æä¾›MR_NEW/MR_DELETEå®
   - operator newå…¨å±€é’©å­
   - é€æ­¥è¿ç§»ç°æœ‰ä»£ç 

8. **å†…å­˜é¢„ç®—ç³»ç»Ÿ**
   - ä¸ºä¸åŒå­ç³»ç»Ÿè®¾ç½®é…é¢
   - è¶…é¢„ç®—æ—¶è§¦å‘å‹ç¼©/è­¦å‘Š
   - å‚è€ƒUE5 Memory Budget Manager

9. **å¯è§†åŒ–è°ƒè¯•UI**
   - ImGuié›†æˆå†…å­˜æ°´ä½å›¾
   - å®æ—¶æ˜¾ç¤ºå„æ± ä½¿ç”¨æƒ…å†µ
   - å†å²å³°å€¼ä¸è¶‹åŠ¿åˆ†æ

### å…³é”®ä¼˜åŒ–æŠ€æœ¯æ€»ç»“

| æŠ€æœ¯ | åŸç† | æ•ˆæœ |
|------|------|------|
| **æ¯æ¡¶é”** | åˆ†æ•£ç«äº‰ç‚¹ | å¹¶å‘æå‡10x |
| **TLSç¼“å­˜** | æ¶ˆé™¤é”è·¯å¾„ | å»¶è¿Ÿé™ä½15x |
| **ç¼“å­˜è¡Œå¯¹é½** | é¿å…false sharing | CPUç¼“å­˜å‘½ä¸­ç‡+20% |
| **ç©ºé—²åˆ—è¡¨** | ç©ºé—´å¤ç”¨ | ç¢ç‰‡ç‡-50% |
| **ç©ºé¡µå›æ”¶** | åŠæ—¶é‡Šæ”¾ | å³°å€¼å†…å­˜-30% |
| **åŸå­æ“ä½œ** | æ— é”bumpåˆ†é… | Frame scratché›¶ç«äº‰ |
| **åŒºé—´åˆå¹¶** | ç›¸é‚»ç©ºé—²åˆå¹¶ | ç¢ç‰‡æ•°é‡-80% |

### å‚è€ƒèµ„æ–™

#### UE5æºç 
- `Engine/Source/Runtime/Core/Public/HAL/MallocBinned2.h` - ä¸»å®ç°
- `Engine/Source/Runtime/Core/Private/HAL/MallocBinned2.cpp` - æ ¸å¿ƒé€»è¾‘
- `Engine/Source/Runtime/Core/Public/HAL/ThreadHeapAllocator.h` - TLSç¼“å­˜

#### ç›¸å…³è®ºæ–‡ä¸æ–‡ç« 
- [TCMalloc: Thread-Caching Malloc](https://github.com/google/tcmalloc)
- [jemalloc: Memory Allocator](http://jemalloc.net/)
- [Hoard: A Scalable Memory Allocator](https://github.com/emeryberger/Hoard)
- [False Sharing and Cache Line Alignment](https://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html)

---

*æœ¬æ¬¡æ›´æ–°æ—¶é—´: 2025-10-28*  
*MonsterEngineç‰ˆæœ¬: å¼€å‘ç‰ˆæœ¬ v0.4.0*  
*ä½œè€…: MonsterEngineå¼€å‘å›¢é˜Ÿ*  
*æœ€åæ›´æ–°: å†…å­˜ç³»ç»Ÿå®Œå–„å®ç°ï¼ˆv2ï¼‰*

---

