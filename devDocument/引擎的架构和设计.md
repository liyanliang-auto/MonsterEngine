# MonsterEngine å¼•æ“æ¶æ„å’Œè®¾è®¡æ–‡æ¡£

## ç›®å½•
1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æ•´ä½“æ¶æ„](#æ•´ä½“æ¶æ„)
3. [æ ¸å¿ƒæ¨¡å—åˆ†æ](#æ ¸å¿ƒæ¨¡å—åˆ†æ)
4. [RHI æ¸²æŸ“ç¡¬ä»¶æ¥å£è®¾è®¡](#rhi-æ¸²æŸ“ç¡¬ä»¶æ¥å£è®¾è®¡)
5. [å¹³å°æŠ½è±¡å±‚](#å¹³å°æŠ½è±¡å±‚)
6. [ç±»å›¾å’Œå…³ç³»](#ç±»å›¾å’Œå…³ç³»)
7. [æ•°æ®æµç¨‹](#æ•°æ®æµç¨‹)
8. [è®¾è®¡æ¨¡å¼å’ŒåŸåˆ™](#è®¾è®¡æ¨¡å¼å’ŒåŸåˆ™)
9. [å†…å­˜ç®¡ç†ç­–ç•¥](#å†…å­˜ç®¡ç†ç­–ç•¥)
10. [æ€§èƒ½è€ƒè™‘](#æ€§èƒ½è€ƒè™‘)
11. [æ‰©å±•æ€§è®¾è®¡](#æ‰©å±•æ€§è®¾è®¡)

---

## é¡¹ç›®æ¦‚è¿°

MonsterEngine æ˜¯ä¸€ä¸ªåŸºäºç°ä»£C++20æ ‡å‡†å¼€å‘çš„æ¸²æŸ“å¼•æ“ï¼Œå…¶æ ¸å¿ƒæ¶æ„è®¾è®¡å‚è€ƒäº†è™šå¹»å¼•æ“5 (UE5) çš„RHI (Render Hardware Interface) æ¶æ„æ¨¡å¼ã€‚è¯¥å¼•æ“é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œå®ç°äº†è·¨å¹³å°å›¾å½¢APIçš„æŠ½è±¡ï¼Œç›®å‰ä¸»è¦æ”¯æŒVulkanåç«¯ï¼Œå¹¶ä¸ºæœªæ¥æ”¯æŒDirect3D 12ã€Direct3D 11ã€OpenGLå’ŒMetalç­‰å›¾å½¢APIå¥ å®šäº†åŸºç¡€ã€‚

### æ ¸å¿ƒè®¾è®¡ç›®æ ‡
- **è·¨å¹³å°æ”¯æŒ**: Windowsã€Linuxã€Android
- **å¤šå›¾å½¢APIæ”¯æŒ**: Vulkanã€D3D12ã€D3D11ã€OpenGLã€Metal
- **ç°ä»£C++è®¾è®¡**: ä½¿ç”¨C++20ç‰¹æ€§ï¼ŒRAIIåŸåˆ™ï¼Œæ™ºèƒ½æŒ‡é’ˆ
- **æ¨¡å—åŒ–æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚å’Œæ¨¡å—åŒ–è®¾è®¡
- **é«˜æ€§èƒ½æ¸²æŸ“**: GPUé©±åŠ¨æ¸²æŸ“ï¼Œæœ€å°åŒ–CPUå¼€é”€
- **è°ƒè¯•å‹å¥½**: å®Œå–„çš„è°ƒè¯•æ”¯æŒå’ŒéªŒè¯å±‚

---

## æ•´ä½“æ¶æ„

MonsterEngine é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œä»ä¸Šåˆ°ä¸‹åˆ†ä¸ºä»¥ä¸‹å‡ å±‚ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨å±‚ (Application)                    â”‚
â”‚              main.cpp + TriangleRenderer                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   å¼•æ“å±‚ (Engine)                        â”‚
â”‚                   Engine.h/cpp                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 é«˜çº§æ¸²æŸ“å±‚ (Renderer)                     â”‚
â”‚               Renderer Module (æœªæ¥æ‰©å±•)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ¸²æŸ“ç¡¬ä»¶æ¥å£å±‚ (RHI Layer)                    â”‚
â”‚    IRHIDevice â”‚ IRHICommandList â”‚ IRHIResource           â”‚
â”‚         RHI.h â”‚ RHIDefinitions.h â”‚ æŠ½è±¡æ¥å£               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             å¹³å°å®ç°å±‚ (Platform Layer)                    â”‚
â”‚   VulkanDevice â”‚ D3D12Device â”‚ OpenGLDevice (æœªæ¥)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å›¾å½¢APIå±‚ (Graphics APIs)                   â”‚
â”‚        Vulkan â”‚ Direct3D 12 â”‚ OpenGL â”‚ Metal           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¶æ„ç‰¹ç‚¹

1. **åˆ†å±‚è§£è€¦**: æ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼Œå±‚ä¸å±‚ä¹‹é—´é€šè¿‡æ¥å£é€šä¿¡
2. **æ¥å£æŠ½è±¡**: RHIå±‚æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œéšè—åº•å±‚å›¾å½¢APIå·®å¼‚
3. **å·¥å‚æ¨¡å¼**: ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºå¹³å°ç‰¹å®šçš„å®ç°
4. **RAIIç®¡ç†**: æ‰€æœ‰èµ„æºä½¿ç”¨RAIIåŸåˆ™ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
5. **ç°ä»£C++**: å¹¿æ³›ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆã€æ¨¡æ¿ã€æ¦‚å¿µç­‰C++20ç‰¹æ€§

---

## æ ¸å¿ƒæ¨¡å—åˆ†æ

### 1. Core æ¨¡å—

Core æ¨¡å—æä¾›å¼•æ“çš„åŸºç¡€è®¾æ–½å’Œå·¥å…·ç±»ï¼š

```cpp
Core/
â”œâ”€â”€ CoreMinimal.h        // æ ¸å¿ƒåŒ…å«æ–‡ä»¶
â”œâ”€â”€ CoreTypes.h          // åŸºç¡€ç±»å‹å®šä¹‰
â”œâ”€â”€ Log.h/.cpp          // æ—¥å¿—ç³»ç»Ÿ
â””â”€â”€ Assert.h            // æ–­è¨€ç³»ç»Ÿ
```

#### å…³é”®ç‰¹æ€§
- **ç±»å‹åˆ«å**: æä¾›UE5é£æ ¼çš„ç±»å‹åˆ«å (TSharedPtr, TUniquePtr, TArrayç­‰)
- **å¹³å°æ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹ç›®æ ‡å¹³å° (Windows, Linux)
- **æ—¥å¿—ç³»ç»Ÿ**: å¤šçº§åˆ«æ—¥å¿—æ”¯æŒ (DEBUG, INFO, WARNING, ERROR)
- **æ–­è¨€ç³»ç»Ÿ**: è°ƒè¯•ç‰ˆæœ¬çš„è¿è¡Œæ—¶æ£€æŸ¥

#### ç±»å‹ç³»ç»Ÿè®¾è®¡
```cpp
// æ™ºèƒ½æŒ‡é’ˆ (å‚è€ƒUE5è®¾è®¡)
template<typename T> using TSharedPtr = std::shared_ptr<T>;
template<typename T> using TUniquePtr = std::unique_ptr<T>;
template<typename T> using TWeakPtr = std::weak_ptr<T>;

// å®¹å™¨ç±»å‹
template<typename T> using TArray = std::vector<T>;
template<typename T> using TSpan = std::span<T>;
template<typename Key, typename Value> using TMap = std::unordered_map<Key, Value>;
```

### 2. RHI æ¨¡å—

RHI (Render Hardware Interface) æ¨¡å—æ˜¯å¼•æ“çš„æ ¸å¿ƒæ¸²æŸ“æŠ½è±¡å±‚ï¼š

```cpp
RHI/
â”œâ”€â”€ RHI.h                   // RHIå·¥å‚å’Œåˆ›å»ºä¿¡æ¯
â”œâ”€â”€ RHIDefinitions.h        // RHIç±»å‹å’Œæšä¸¾å®šä¹‰
â”œâ”€â”€ IRHIDevice.h           // è®¾å¤‡æ¥å£
â”œâ”€â”€ IRHICommandList.h      // å‘½ä»¤åˆ—è¡¨æ¥å£
â””â”€â”€ IRHIResource.h         // èµ„æºåŸºç±»æ¥å£
```

#### è®¾è®¡åŸåˆ™
- **æ¥å£åˆ†ç¦»**: æ¯ä¸ªåŠŸèƒ½éƒ½æœ‰ç‹¬ç«‹çš„æ¥å£
- **èµ„æºç®¡ç†**: ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æºç”Ÿå‘½å‘¨æœŸ
- **çŠ¶æ€è·Ÿè¸ª**: æ”¯æŒæ˜¾å¼èµ„æºçŠ¶æ€è½¬æ¢
- **è°ƒè¯•æ”¯æŒ**: å†…ç½®è°ƒè¯•äº‹ä»¶å’Œæ ‡è®°æ”¯æŒ

### 3. Platform æ¨¡å—

Platform æ¨¡å—åŒ…å«å„å›¾å½¢APIçš„å…·ä½“å®ç°ï¼š

```cpp
Platform/
â””â”€â”€ Vulkan/
    â”œâ”€â”€ VulkanRHI.h         // VulkanåŸºç¡€å®šä¹‰
    â”œâ”€â”€ VulkanDevice.h      // Vulkanè®¾å¤‡å®ç°
    â”œâ”€â”€ VulkanCommandList.h // Vulkanå‘½ä»¤åˆ—è¡¨
    â”œâ”€â”€ VulkanBuffer.h      // Vulkanç¼“å†²åŒº
    â”œâ”€â”€ VulkanTexture.h     // Vulkançº¹ç†
    â”œâ”€â”€ VulkanShader.h      // Vulkanç€è‰²å™¨
    â””â”€â”€ VulkanUtils.h       // Vulkanå·¥å…·å‡½æ•°
```

### 4. Engine æ¨¡å—

Engine æ¨¡å—æ˜¯å¼•æ“çš„ä¸»å…¥å£ç‚¹ï¼Œè´Ÿè´£åˆå§‹åŒ–å’Œç®¡ç†å„ä¸ªå­ç³»ç»Ÿï¼š

```cpp
class Engine {
public:
    bool initialize(const RHI::RHICreateInfo& rhiCreateInfo);
    void shutdown();
    void run();
    RHI::IRHIDevice* getRHIDevice() const;
    
private:
    TUniquePtr<RHI::IRHIDevice> m_rhiDevice;
    bool m_initialized = false;
    bool m_shouldRun = true;
};
```

---

## RHI æ¸²æŸ“ç¡¬ä»¶æ¥å£è®¾è®¡

RHIå±‚æ˜¯MonsterEngineçš„æ ¸å¿ƒè®¾è®¡ï¼Œå®ƒæä¾›äº†ç»Ÿä¸€çš„æ¸²æŸ“æ¥å£ï¼Œå±è”½äº†ä¸åŒå›¾å½¢APIä¹‹é—´çš„å·®å¼‚ã€‚

### RHI æ¶æ„å›¾

```mermaid
graph TB
    subgraph "RHI Interfaces"
        IRHIDevice["IRHIDevice<br/>è®¾å¤‡æ¥å£"]
        IRHICommandList["IRHICommandList<br/>å‘½ä»¤åˆ—è¡¨æ¥å£"]
        IRHIResource["IRHIResource<br/>èµ„æºåŸºç±»"]
        IRHIBuffer["IRHIBuffer<br/>ç¼“å†²åŒºæ¥å£"]
        IRHITexture["IRHITexture<br/>çº¹ç†æ¥å£"]
        IRHIShader["IRHIShader<br/>ç€è‰²å™¨æ¥å£"]
        IRHIPipelineState["IRHIPipelineState<br/>ç®¡é“çŠ¶æ€æ¥å£"]
    end
    
    subgraph "RHI Factory"
        RHIFactory["RHIFactory<br/>å·¥å‚ç±»"]
        RHICreateInfo["RHICreateInfo<br/>åˆ›å»ºå‚æ•°"]
    end
    
    subgraph "Platform Implementations"
        VulkanDevice["VulkanDevice"]
        VulkanCommandList["VulkanCommandList"]
        VulkanBuffer["VulkanBuffer"]
        D3D12Device["D3D12Device<br/>(è®¡åˆ’ä¸­)"]
        OpenGLDevice["OpenGLDevice<br/>(è®¡åˆ’ä¸­)"]
    end
    
    RHIFactory --> IRHIDevice
    IRHIDevice --> IRHICommandList
    IRHIDevice --> IRHIResource
    IRHIResource --> IRHIBuffer
    IRHIResource --> IRHITexture
    IRHIDevice --> IRHIShader
    IRHIDevice --> IRHIPipelineState
    
    IRHIDevice -.-> VulkanDevice
    IRHIDevice -.-> D3D12Device
    IRHIDevice -.-> OpenGLDevice
    IRHICommandList -.-> VulkanCommandList
    IRHIBuffer -.-> VulkanBuffer
```

### æ ¸å¿ƒæ¥å£è®¾è®¡

#### 1. IRHIDevice - è®¾å¤‡æ¥å£

IRHIDevice æ˜¯RHIå±‚çš„æ ¸å¿ƒæ¥å£ï¼Œè´Ÿè´£ç®¡ç†GPUè®¾å¤‡å’Œåˆ›å»ºå„ç§æ¸²æŸ“èµ„æºï¼š

```cpp
class IRHIDevice {
public:
    // è®¾å¤‡èƒ½åŠ›æŸ¥è¯¢
    virtual const RHIDeviceCapabilities& getCapabilities() const = 0;
    
    // èµ„æºåˆ›å»º
    virtual TSharedPtr<IRHIBuffer> createBuffer(const BufferDesc& desc) = 0;
    virtual TSharedPtr<IRHITexture> createTexture(const TextureDesc& desc) = 0;
    virtual TSharedPtr<IRHIVertexShader> createVertexShader(TSpan<const uint8> bytecode) = 0;
    virtual TSharedPtr<IRHIPixelShader> createPixelShader(TSpan<const uint8> bytecode) = 0;
    virtual TSharedPtr<IRHIPipelineState> createPipelineState(const PipelineStateDesc& desc) = 0;
    
    // å‘½ä»¤åˆ—è¡¨ç®¡ç†
    virtual TSharedPtr<IRHICommandList> createCommandList() = 0;
    virtual void executeCommandLists(TSpan<TSharedPtr<IRHICommandList>> commandLists) = 0;
    virtual IRHICommandList* getImmediateCommandList() = 0;
    
    // åŒæ­¥å’Œå‘ˆç°
    virtual void waitForIdle() = 0;
    virtual void present() = 0;
};
```

#### 2. IRHICommandList - å‘½ä»¤åˆ—è¡¨æ¥å£

IRHICommandList è´Ÿè´£è®°å½•æ¸²æŸ“å‘½ä»¤ï¼Œæ”¯æŒå»¶è¿Ÿæ‰§è¡Œï¼š

```cpp
class IRHICommandList {
public:
    // å‘½ä»¤è®°å½•æ§åˆ¶
    virtual void begin() = 0;
    virtual void end() = 0;
    virtual void reset() = 0;
    
    // èµ„æºç»‘å®š
    virtual void setPipelineState(TSharedPtr<IRHIPipelineState> pipelineState) = 0;
    virtual void setVertexBuffers(uint32 startSlot, TSpan<TSharedPtr<IRHIBuffer>> vertexBuffers) = 0;
    virtual void setIndexBuffer(TSharedPtr<IRHIBuffer> indexBuffer, bool is32Bit = true) = 0;
    
    // æ¸²æŸ“çŠ¶æ€è®¾ç½®
    virtual void setViewport(const Viewport& viewport) = 0;
    virtual void setScissorRect(const ScissorRect& scissorRect) = 0;
    virtual void setRenderTargets(TSpan<TSharedPtr<IRHITexture>> renderTargets,
                                TSharedPtr<IRHITexture> depthStencil = nullptr) = 0;
    
    // ç»˜åˆ¶å‘½ä»¤
    virtual void draw(uint32 vertexCount, uint32 startVertexLocation = 0) = 0;
    virtual void drawIndexed(uint32 indexCount, uint32 startIndexLocation = 0,
                           int32 baseVertexLocation = 0) = 0;
    
    // èµ„æºæ¸…ç†å’Œè½¬æ¢
    virtual void clearRenderTarget(TSharedPtr<IRHITexture> renderTarget, const float32 clearColor[4]) = 0;
    virtual void transitionResource(TSharedPtr<IRHIResource> resource, 
                                  EResourceUsage stateBefore, EResourceUsage stateAfter) = 0;
};
```

### RHI ç±»å‹ç³»ç»Ÿ

RHI å®šä¹‰äº†å®Œæ•´çš„ç±»å‹ç³»ç»Ÿæ¥æè¿°æ¸²æŸ“èµ„æºå’ŒçŠ¶æ€ï¼š

#### èµ„æºä½¿ç”¨æ ‡å¿—
```cpp
enum class EResourceUsage : uint32 {
    None = 0,
    VertexBuffer = 1 << 0,
    IndexBuffer = 1 << 1,
    UniformBuffer = 1 << 2,
    StorageBuffer = 1 << 3,
    TransferSrc = 1 << 4,
    TransferDst = 1 << 5,
    RenderTarget = 1 << 6,
    DepthStencil = 1 << 7,
    ShaderResource = 1 << 8,
    UnorderedAccess = 1 << 9
};
```

#### ç¼“å†²åŒºæè¿°
```cpp
struct BufferDesc {
    uint32 size = 0;
    EResourceUsage usage = EResourceUsage::None;
    bool cpuAccessible = false;
    String debugName;
};
```

#### çº¹ç†æè¿°
```cpp
struct TextureDesc {
    uint32 width = 1;
    uint32 height = 1;
    uint32 depth = 1;
    uint32 mipLevels = 1;
    uint32 arraySize = 1;
    EPixelFormat format = EPixelFormat::R8G8B8A8_UNORM;
    EResourceUsage usage = EResourceUsage::ShaderResource;
    String debugName;
};
```

### RHI å·¥å‚æ¨¡å¼

RHI ä½¿ç”¨å·¥å‚æ¨¡å¼æ¥åˆ›å»ºå¹³å°ç‰¹å®šçš„å®ç°ï¼š

```cpp
class RHIFactory {
public:
    static TUniquePtr<IRHIDevice> createDevice(const RHICreateInfo& createInfo);
    static TArray<ERHIBackend> getAvailableBackends();
    static bool isBackendAvailable(ERHIBackend backend);
    static const char* getBackendName(ERHIBackend backend);
    static ERHIBackend selectBestBackend();
};
```

#### RHIåˆ›å»ºä¿¡æ¯
```cpp
struct RHICreateInfo {
    ERHIBackend preferredBackend = ERHIBackend::Vulkan;
    bool enableValidation = false;
    bool enableDebugMarkers = true;
    String applicationName = "MonsterRender Application";
    uint32 applicationVersion = 1;
    void* windowHandle = nullptr;
    uint32 windowWidth = 1920;
    uint32 windowHeight = 1080;
};
```

---

## å¹³å°æŠ½è±¡å±‚

### Vulkan å®ç°

å½“å‰å¼•æ“ä¸»è¦å®ç°äº†Vulkanåç«¯ï¼Œæä¾›äº†å®Œæ•´çš„Vulkan APIå°è£…ï¼š

#### VulkanDevice æ¶æ„

```cpp
class VulkanDevice : public IRHIDevice {
private:
    // Vulkanæ ¸å¿ƒå¯¹è±¡
    VkInstance m_instance;
    VkPhysicalDevice m_physicalDevice;
    VkDevice m_device;
    
    // é˜Ÿåˆ—ç®¡ç†
    VkQueue m_graphicsQueue;
    VkQueue m_presentQueue;
    QueueFamily m_graphicsQueueFamily;
    QueueFamily m_presentQueueFamily;
    
    // äº¤æ¢é“¾
    VkSwapchainKHR m_swapchain;
    TArray<VkImage> m_swapchainImages;
    TArray<VkImageView> m_swapchainImageViews;
    
    // å‘½ä»¤å¤„ç†
    VkCommandPool m_commandPool;
    TUniquePtr<VulkanCommandList> m_immediateCommandList;
    
    // åŒæ­¥å¯¹è±¡
    TArray<VkSemaphore> m_imageAvailableSemaphores;
    TArray<VkSemaphore> m_renderFinishedSemaphores;
    TArray<VkFence> m_inFlightFences;
};
```

#### Vulkan åˆå§‹åŒ–æµç¨‹

```mermaid
graph TD
    A[createInstance] --> B[setupDebugMessenger]
    B --> C[createSurface]
    C --> D[selectPhysicalDevice]
    D --> E[createLogicalDevice]
    E --> F[createSwapchain]
    F --> G[createCommandPool]
    G --> H[createSyncObjects]
    H --> I[VulkanDevice Ready]
```

#### é˜Ÿåˆ—æ—ç®¡ç†

```cpp
struct QueueFamily {
    uint32 familyIndex = VK_QUEUE_FAMILY_IGNORED;
    uint32 queueCount = 0;
    VkQueueFlags flags = 0;
    bool supportsPresentToSurface = false;
};
```

### æœªæ¥å¹³å°æ”¯æŒ

å¼•æ“è®¾è®¡æ”¯æŒå¤šä¸ªå›¾å½¢APIåç«¯ï¼š

- **Direct3D 12**: ç°ä»£ä½çº§åˆ«APIï¼ŒWindowså¹³å°ä¸»è¦é€‰æ‹©
- **Direct3D 11**: ä¼ ç»Ÿé«˜çº§åˆ«APIï¼Œå‘åå…¼å®¹
- **OpenGL**: è·¨å¹³å°æ”¯æŒï¼ŒLinuxå’Œç§»åŠ¨å¹³å°
- **Metal**: Appleç”Ÿæ€ç³»ç»Ÿæ”¯æŒ

---

## ç±»å›¾å’Œå…³ç³»

### æ ¸å¿ƒç±»å±‚æ¬¡ç»“æ„

```mermaid
classDiagram
    class Engine {
        -TUniquePtr~IRHIDevice~ m_rhiDevice
        -bool m_initialized
        -bool m_shouldRun
        +initialize(RHICreateInfo) bool
        +shutdown() void
        +run() void
        +getRHIDevice() IRHIDevice*
    }
    
    class IRHIDevice {
        <<interface>>
        +getCapabilities() RHIDeviceCapabilities
        +createBuffer(BufferDesc) TSharedPtr~IRHIBuffer~
        +createTexture(TextureDesc) TSharedPtr~IRHITexture~
        +createCommandList() TSharedPtr~IRHICommandList~
        +waitForIdle() void
        +present() void
    }
    
    class VulkanDevice {
        -VkInstance m_instance
        -VkDevice m_device
        -VkPhysicalDevice m_physicalDevice
        -VkQueue m_graphicsQueue
        -VkSwapchainKHR m_swapchain
        +initialize(RHICreateInfo) bool
        +shutdown() void
    }
    
    class IRHICommandList {
        <<interface>>
        +begin() void
        +end() void
        +setPipelineState(IRHIPipelineState) void
        +setVertexBuffers(TSpan~IRHIBuffer~) void
        +draw(uint32, uint32) void
        +drawIndexed(uint32, uint32, int32) void
    }
    
    class VulkanCommandList {
        -VkCommandBuffer m_commandBuffer
        -VulkanDevice* m_device
        -bool m_isRecording
        +begin() void
        +end() void
    }
    
    class IRHIResource {
        <<interface>>
        +getResourceType() EResourceType
        +setDebugName(String) void
    }
    
    class IRHIBuffer {
        <<interface>>
        +getSize() uint32
        +getUsage() EResourceUsage
        +map() void*
        +unmap() void
    }
    
    class IRHITexture {
        <<interface>>
        +getWidth() uint32
        +getHeight() uint32
        +getFormat() EPixelFormat
        +getMipLevels() uint32
    }
    
    class RHIFactory {
        <<static>>
        +createDevice(RHICreateInfo) TUniquePtr~IRHIDevice~
        +getAvailableBackends() TArray~ERHIBackend~
        +selectBestBackend() ERHIBackend
    }
    
    Engine --> IRHIDevice : uses
    IRHIDevice <|.. VulkanDevice : implements
    IRHICommandList <|.. VulkanCommandList : implements
    IRHIResource <|-- IRHIBuffer : extends
    IRHIResource <|-- IRHITexture : extends
    RHIFactory ..> IRHIDevice : creates
    VulkanDevice --> VulkanCommandList : creates
    IRHIDevice --> IRHICommandList : creates
    IRHIDevice --> IRHIResource : creates
```

### èµ„æºç®¡ç†ç±»å›¾

```mermaid
classDiagram
    class IRHIResource {
        <<interface>>
        #String m_debugName
        +getResourceType() EResourceType
        +setDebugName(String) void
        +getDebugName() String
    }
    
    class IRHIBuffer {
        <<interface>>
        +getSize() uint32
        +getUsage() EResourceUsage
        +isCPUAccessible() bool
        +map() void*
        +unmap() void
    }
    
    class IRHITexture {
        <<interface>>
        +getWidth() uint32
        +getHeight() uint32
        +getDepth() uint32
        +getMipLevels() uint32
        +getArraySize() uint32
        +getFormat() EPixelFormat
        +getUsage() EResourceUsage
    }
    
    class VulkanBuffer {
        -VkBuffer m_buffer
        -VkDeviceMemory m_memory
        -VulkanDevice* m_device
        -BufferDesc m_desc
        -void* m_mappedData
        +map() void*
        +unmap() void
    }
    
    class VulkanTexture {
        -VkImage m_image
        -VkImageView m_imageView
        -VkDeviceMemory m_memory
        -VulkanDevice* m_device
        -TextureDesc m_desc
    }
    
    IRHIResource <|-- IRHIBuffer
    IRHIResource <|-- IRHITexture
    IRHIBuffer <|.. VulkanBuffer
    IRHITexture <|.. VulkanTexture
```

---

## æ•°æ®æµç¨‹

### å¼•æ“åˆå§‹åŒ–æµç¨‹

```mermaid
sequenceDiagram
    participant Main as main()
    participant Engine as Engine
    participant RHIFactory as RHIFactory
    participant VulkanDevice as VulkanDevice
    participant TriangleRenderer as TriangleRenderer
    
    Main->>Engine: new Engine()
    Main->>Engine: initialize(RHICreateInfo)
    Engine->>RHIFactory: createDevice(createInfo)
    RHIFactory->>VulkanDevice: new VulkanDevice()
    VulkanDevice->>VulkanDevice: initialize(createInfo)
    VulkanDevice-->>RHIFactory: device instance
    RHIFactory-->>Engine: TUniquePtr<IRHIDevice>
    Engine-->>Main: initialization result
    
    Main->>Engine: getRHIDevice()
    Engine-->>Main: IRHIDevice*
    
    Main->>TriangleRenderer: new TriangleRenderer()
    Main->>TriangleRenderer: initialize(device)
    TriangleRenderer->>VulkanDevice: createBuffer(vertexDesc)
    TriangleRenderer->>VulkanDevice: createVertexShader(bytecode)
    TriangleRenderer->>VulkanDevice: createPixelShader(bytecode)
    TriangleRenderer->>VulkanDevice: createPipelineState(pipelineDesc)
    TriangleRenderer-->>Main: initialization result
```

### æ¸²æŸ“å¾ªç¯æµç¨‹

```mermaid
sequenceDiagram
    participant Main as main()
    participant Engine as Engine
    participant Device as IRHIDevice
    participant CmdList as IRHICommandList
    participant TriangleRenderer as TriangleRenderer
    
    Main->>Device: getImmediateCommandList()
    Device-->>Main: IRHICommandList*
    
    Main->>CmdList: begin()
    Main->>TriangleRenderer: render(cmdList)
    
    TriangleRenderer->>CmdList: setPipelineState(m_pipelineState)
    TriangleRenderer->>CmdList: setVertexBuffers({m_vertexBuffer})
    TriangleRenderer->>CmdList: setViewport(viewport)
    TriangleRenderer->>CmdList: draw(vertexCount)
    
    Main->>CmdList: end()
    Main->>Device: present()
    Main->>Device: waitForIdle()
```

### èµ„æºåˆ›å»ºæµç¨‹

```mermaid
flowchart TD
    A[åº”ç”¨è¯·æ±‚åˆ›å»ºèµ„æº] --> B{æ£€æŸ¥èµ„æºç±»å‹}
    
    B -->|Buffer| C[åˆ›å»ºBufferDesc]
    B -->|Texture| D[åˆ›å»ºTextureDesc]
    B -->|Shader| E[åŠ è½½ç€è‰²å™¨å­—èŠ‚ç ]
    
    C --> F[IRHIDevice::createBuffer]
    D --> G[IRHIDevice::createTexture]
    E --> H[IRHIDevice::createVertexShader]
    
    F --> I[VulkanDeviceå®ç°]
    G --> I
    H --> I
    
    I --> J[åˆ†é…Vulkanèµ„æº]
    J --> K[åˆ†é…GPUå†…å­˜]
    K --> L[ç»‘å®šèµ„æºå’Œå†…å­˜]
    L --> M[è®¾ç½®è°ƒè¯•åç§°]
    M --> N[è¿”å›æ™ºèƒ½æŒ‡é’ˆåŒ…è£…çš„èµ„æº]
    
    N --> O[åº”ç”¨ä½¿ç”¨èµ„æº]
    O --> P[èµ„æºè¶…å‡ºä½œç”¨åŸŸ]
    P --> Q[æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾]
    Q --> R[è°ƒç”¨ææ„å‡½æ•°]
    R --> S[é‡Šæ”¾Vulkanèµ„æºå’Œå†…å­˜]
```

---

## è®¾è®¡æ¨¡å¼å’ŒåŸåˆ™

### 1. å·¥å‚æ¨¡å¼ (Factory Pattern)

**åº”ç”¨åœºæ™¯**: RHIè®¾å¤‡åˆ›å»º

```cpp
class RHIFactory {
public:
    static TUniquePtr<IRHIDevice> createDevice(const RHICreateInfo& createInfo) {
        switch(createInfo.preferredBackend) {
            case ERHIBackend::Vulkan:
                return MakeUnique<VulkanDevice>();
            case ERHIBackend::D3D12:
                // return MakeUnique<D3D12Device>();
            default:
                return nullptr;
        }
    }
};
```

**ä¼˜åŠ¿**:
- éšè—å…·ä½“å®ç°çš„åˆ›å»ºç»†èŠ‚
- æ”¯æŒè¿è¡Œæ—¶åç«¯é€‰æ‹©
- ä¾¿äºæ·»åŠ æ–°çš„å›¾å½¢APIåç«¯

### 2. æŠ½è±¡å·¥å‚æ¨¡å¼ (Abstract Factory)

**åº”ç”¨åœºæ™¯**: å¹³å°ç‰¹å®šçš„èµ„æºåˆ›å»º

æ¯ä¸ªå¹³å°çš„Deviceä½œä¸ºå·¥å‚ï¼Œåˆ›å»ºå¯¹åº”å¹³å°çš„èµ„æºï¼š
```cpp
// VulkanDevice ä½œä¸º Vulkan èµ„æºçš„æŠ½è±¡å·¥å‚
class VulkanDevice : public IRHIDevice {
public:
    TSharedPtr<IRHIBuffer> createBuffer(const BufferDesc& desc) override {
        return MakeShared<VulkanBuffer>(this, desc);
    }
    
    TSharedPtr<IRHITexture> createTexture(const TextureDesc& desc) override {
        return MakeShared<VulkanTexture>(this, desc);
    }
};
```

### 3. æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation)

**åº”ç”¨åœºæ™¯**: RHIæ¥å£è®¾è®¡

å°†å¤§å‹æ¥å£æ‹†åˆ†ä¸ºå¤šä¸ªä¸“ç”¨æ¥å£ï¼š
- `IRHIDevice` - è®¾å¤‡ç®¡ç†å’Œèµ„æºåˆ›å»º
- `IRHICommandList` - å‘½ä»¤è®°å½•å’Œæ‰§è¡Œ
- `IRHIResource` - èµ„æºåŸºç±»
- `IRHIBuffer` - ç¼“å†²åŒºç‰¹å®šæ“ä½œ
- `IRHITexture` - çº¹ç†ç‰¹å®šæ“ä½œ

### 4. RAII (Resource Acquisition Is Initialization)

**åº”ç”¨åœºæ™¯**: èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†

```cpp
class VulkanBuffer : public IRHIBuffer {
public:
    VulkanBuffer(VulkanDevice* device, const BufferDesc& desc) 
        : m_device(device), m_desc(desc) {
        // æ„é€ æ—¶åˆ›å»ºVulkanèµ„æº
        createVulkanBuffer();
    }
    
    ~VulkanBuffer() {
        // ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾Vulkanèµ„æº
        destroyVulkanBuffer();
    }
};
```

### 5. æ™ºèƒ½æŒ‡é’ˆç®¡ç† (Smart Pointer Management)

**åº”ç”¨åœºæ™¯**: è‡ªåŠ¨å†…å­˜ç®¡ç†

```cpp
// ç‹¬å æ‰€æœ‰æƒ
TUniquePtr<IRHIDevice> m_rhiDevice;

// å…±äº«æ‰€æœ‰æƒ
TSharedPtr<IRHIBuffer> m_vertexBuffer;
TSharedPtr<IRHIPipelineState> m_pipelineState;

// å¼±å¼•ç”¨ï¼ˆé¿å…å¾ªç¯å¼•ç”¨ï¼‰
TWeakPtr<IRHIDevice> m_parentDevice;
```

### 6. å‘½ä»¤æ¨¡å¼ (Command Pattern)

**åº”ç”¨åœºæ™¯**: æ¸²æŸ“å‘½ä»¤è®°å½•

```cpp
class IRHICommandList {
public:
    // æ¯ä¸ªæ–¹æ³•éƒ½æ˜¯ä¸€ä¸ªå‘½ä»¤ï¼Œå»¶è¿Ÿæ‰§è¡Œ
    virtual void draw(uint32 vertexCount, uint32 startVertexLocation = 0) = 0;
    virtual void drawIndexed(uint32 indexCount, uint32 startIndexLocation = 0) = 0;
    virtual void setPipelineState(TSharedPtr<IRHIPipelineState> pipelineState) = 0;
};
```

### 7. æ¨¡æ¿å…ƒç¼–ç¨‹å’Œç±»å‹å®‰å…¨

**åº”ç”¨åœºæ™¯**: ç±»å‹å®‰å…¨çš„æ™ºèƒ½æŒ‡é’ˆåˆ«å

```cpp
template<typename T>
using TSharedPtr = std::shared_ptr<T>;

template<typename T, typename... Args>
constexpr TSharedPtr<T> MakeShared(Args&&... args) {
    return std::make_shared<T>(std::forward<Args>(args)...);
}
```

---

## å†…å­˜ç®¡ç†ç­–ç•¥

### 1. æ™ºèƒ½æŒ‡é’ˆç­–ç•¥

MonsterEngineé‡‡ç”¨ç°ä»£C++çš„æ™ºèƒ½æŒ‡é’ˆè¿›è¡Œå†…å­˜ç®¡ç†ï¼š

#### æ‰€æœ‰æƒæ¨¡å‹
```cpp
// ç‹¬å æ‰€æœ‰æƒ - å¼•æ“æ ¸å¿ƒç»„ä»¶
TUniquePtr<RHI::IRHIDevice> m_rhiDevice;     // Engineæ‹¥æœ‰è®¾å¤‡

// å…±äº«æ‰€æœ‰æƒ - æ¸²æŸ“èµ„æº
TSharedPtr<IRHIBuffer> m_vertexBuffer;        // å¯è¢«å¤šä¸ªå¯¹è±¡å…±äº«
TSharedPtr<IRHIPipelineState> m_pipelineState; // ç®¡é“çŠ¶æ€å¯é‡ç”¨

// å¼±å¼•ç”¨ - é¿å…å¾ªç¯å¼•ç”¨
TWeakPtr<IRHIDevice> m_parentDevice;          // å­å¯¹è±¡å¼•ç”¨çˆ¶è®¾å¤‡
```

#### èµ„æºåˆ›å»ºæ¨¡å¼
```cpp
// ä½¿ç”¨å·¥å‚å‡½æ•°åˆ›å»ºèµ„æºï¼Œè¿”å›æ™ºèƒ½æŒ‡é’ˆ
auto buffer = device->createBuffer(bufferDesc);
auto texture = device->createTexture(textureDesc);
auto pipeline = device->createPipelineState(pipelineDesc);

// è‡ªåŠ¨ææ„ï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾
```

### 2. GPUå†…å­˜ç®¡ç†

#### Vulkanå†…å­˜åˆ†é…ç­–ç•¥
```cpp
class VulkanBuffer : public IRHIBuffer {
private:
    VkBuffer m_buffer;
    VkDeviceMemory m_memory;
    
    // å†…å­˜ç±»å‹é€‰æ‹©
    uint32 findMemoryType(uint32 typeFilter, VkMemoryPropertyFlags properties);
    
    // å†…å­˜æ˜ å°„çŠ¶æ€
    void* m_mappedData = nullptr;
    bool m_isPersistentlyMapped = false;
};
```

#### å†…å­˜æ± å’Œåˆ†é…å™¨
```cpp
// æœªæ¥æ‰©å±•ï¼šå†…å­˜åˆ†é…å™¨
class GPUMemoryAllocator {
public:
    struct Allocation {
        VkDeviceMemory memory;
        VkDeviceSize offset;
        VkDeviceSize size;
    };
    
    Allocation allocate(VkDeviceSize size, VkDeviceSize alignment, uint32 memoryType);
    void deallocate(const Allocation& allocation);
};
```

### 3. CPUå†…å­˜ä¼˜åŒ–

#### å¯¹è±¡æ± æ¨¡å¼
```cpp
template<typename T>
class ObjectPool {
private:
    std::vector<std::unique_ptr<T>> m_pool;
    std::queue<T*> m_available;
    
public:
    T* acquire() {
        if (m_available.empty()) {
            m_pool.emplace_back(std::make_unique<T>());
            return m_pool.back().get();
        }
        T* obj = m_available.front();
        m_available.pop();
        return obj;
    }
    
    void release(T* obj) {
        obj->reset();  // é‡ç½®å¯¹è±¡çŠ¶æ€
        m_available.push(obj);
    }
};
```

#### æ ˆåˆ†é…å™¨
```cpp
class StackAllocator {
private:
    uint8* m_data;
    size_t m_size;
    size_t m_offset;
    
public:
    template<typename T>
    T* allocate(size_t count = 1) {
        size_t size = sizeof(T) * count;
        if (m_offset + size > m_size) return nullptr;
        
        T* ptr = reinterpret_cast<T*>(m_data + m_offset);
        m_offset += size;
        return ptr;
    }
    
    void reset() { m_offset = 0; }  // é‡ç½®æ•´ä¸ªåˆ†é…å™¨
};
```

---

## æ€§èƒ½è€ƒè™‘

### 1. GPUæ€§èƒ½ä¼˜åŒ–

#### æ‰¹å¤„ç†å’Œå®ä¾‹åŒ–
```cpp
class BatchRenderer {
public:
    struct DrawCall {
        TSharedPtr<IRHIPipelineState> pipelineState;
        TSharedPtr<IRHIBuffer> vertexBuffer;
        TSharedPtr<IRHIBuffer> indexBuffer;
        uint32 indexCount;
    };
    
    void addDrawCall(const DrawCall& drawCall);
    void flush(IRHICommandList* cmdList);  // æ‰¹é‡æäº¤ç»˜åˆ¶è°ƒç”¨
};
```

#### GPUé©±åŠ¨æ¸²æŸ“
```cpp
// æœªæ¥æ‰©å±•ï¼šé—´æ¥ç»˜åˆ¶
struct IndirectDrawCommand {
    uint32 indexCount;
    uint32 instanceCount;
    uint32 firstIndex;
    uint32 vertexOffset;
    uint32 firstInstance;
};

void IRHICommandList::drawIndexedIndirect(
    TSharedPtr<IRHIBuffer> commandBuffer,
    uint32 drawCount
);
```

#### èµ„æºçŠ¶æ€è·Ÿè¸ª
```cpp
class ResourceStateTracker {
private:
    struct ResourceState {
        TWeakPtr<IRHIResource> resource;
        EResourceUsage currentState;
        EResourceUsage pendingState;
    };
    
    TMap<IRHIResource*, ResourceState> m_states;
    
public:
    void transitionResource(TSharedPtr<IRHIResource> resource, 
                          EResourceUsage newState);
    void flushBarriers(IRHICommandList* cmdList);
};
```

### 2. CPUæ€§èƒ½ä¼˜åŒ–

#### å¤šçº¿ç¨‹å‘½ä»¤åˆ—è¡¨ç”Ÿæˆ
```cpp
class ParallelCommandListManager {
private:
    TArray<TSharedPtr<IRHICommandList>> m_commandLists;
    std::atomic<uint32> m_currentIndex{0};
    
public:
    IRHICommandList* acquireCommandList() {
        uint32 index = m_currentIndex.fetch_add(1) % m_commandLists.size();
        return m_commandLists[index].get();
    }
    
    void submitAll(IRHIDevice* device) {
        device->executeCommandLists(m_commandLists);
    }
};
```

#### æ— é”æ•°æ®ç»“æ„
```cpp
template<typename T>
class LockFreeRingBuffer {
private:
    std::atomic<size_t> m_head{0};
    std::atomic<size_t> m_tail{0};
    TArray<T> m_buffer;
    
public:
    bool enqueue(const T& item);
    bool dequeue(T& item);
};
```

### 3. å†…å­˜å¸¦å®½ä¼˜åŒ–

#### æ•°æ®ç»“æ„ä¼˜åŒ–
```cpp
// SOA (Structure of Arrays) å¸ƒå±€ä¼˜åŒ–ç¼“å­˜å‘½ä¸­ç‡
class ParticleSystemSOA {
private:
    TArray<float32> m_positionsX;
    TArray<float32> m_positionsY; 
    TArray<float32> m_positionsZ;
    TArray<float32> m_velocitiesX;
    TArray<float32> m_velocitiesY;
    TArray<float32> m_velocitiesZ;
    
public:
    void updatePositions(float32 deltaTime);  // å‘é‡åŒ–å‹å¥½
};
```

---

## æ‰©å±•æ€§è®¾è®¡

### 1. æ–°å›¾å½¢APIåç«¯æ‰©å±•

#### æ·»åŠ æ–°åç«¯çš„æ­¥éª¤

1. **åˆ›å»ºå¹³å°ç›®å½•ç»“æ„**:
```cpp
Platform/
â””â”€â”€ D3D12/
    â”œâ”€â”€ D3D12RHI.h
    â”œâ”€â”€ D3D12Device.h
    â”œâ”€â”€ D3D12CommandList.h
    â”œâ”€â”€ D3D12Buffer.h
    â””â”€â”€ D3D12Texture.h
```

2. **å®ç°RHIæ¥å£**:
```cpp
class D3D12Device : public IRHIDevice {
private:
    ComPtr<ID3D12Device> m_device;
    ComPtr<ID3D12CommandQueue> m_commandQueue;
    ComPtr<IDXGISwapChain3> m_swapChain;
    
public:
    // å®ç°æ‰€æœ‰IRHIDeviceæ¥å£
    TSharedPtr<IRHIBuffer> createBuffer(const BufferDesc& desc) override;
    TSharedPtr<IRHITexture> createTexture(const TextureDesc& desc) override;
    // ...
};
```

3. **æ›´æ–°RHIå·¥å‚**:
```cpp
TUniquePtr<IRHIDevice> RHIFactory::createDevice(const RHICreateInfo& createInfo) {
    switch(createInfo.preferredBackend) {
        case ERHIBackend::Vulkan:
            return MakeUnique<VulkanDevice>();
        case ERHIBackend::D3D12:
            return MakeUnique<D3D12Device>();  // æ–°å¢
        case ERHIBackend::D3D11:
            return MakeUnique<D3D11Device>();  // æ–°å¢
        default:
            return nullptr;
    }
}
```

### 2. æ¸²æŸ“åŠŸèƒ½æ‰©å±•

#### æ·»åŠ æ–°çš„æ¸²æŸ“Pass
```cpp
class RenderPass {
public:
    virtual ~RenderPass() = default;
    virtual void execute(IRHICommandList* cmdList, const RenderContext& context) = 0;
    virtual String getName() const = 0;
};

class ShadowMapPass : public RenderPass {
public:
    void execute(IRHICommandList* cmdList, const RenderContext& context) override {
        // å®ç°é˜´å½±è´´å›¾æ¸²æŸ“é€»è¾‘
    }
    String getName() const override { return "ShadowMap"; }
};

class PostProcessPass : public RenderPass {
public:
    void execute(IRHICommandList* cmdList, const RenderContext& context) override {
        // å®ç°åå¤„ç†æ•ˆæœ
    }
    String getName() const override { return "PostProcess"; }
};
```

#### æ¸²æŸ“ç®¡é“æ‰©å±•
```cpp
class RenderPipeline {
private:
    TArray<TUniquePtr<RenderPass>> m_passes;
    
public:
    void addPass(TUniquePtr<RenderPass> pass) {
        m_passes.push_back(std::move(pass));
    }
    
    void execute(IRHICommandList* cmdList, const RenderContext& context) {
        for (auto& pass : m_passes) {
            pass->execute(cmdList, context);
        }
    }
};
```

### 3. å¹³å°ç‰¹æ€§æ”¯æŒ

#### å¹³å°æ£€æµ‹å’ŒåŠŸèƒ½æŸ¥è¯¢
```cpp
class PlatformCapabilities {
public:
    static bool supportsRayTracing();
    static bool supportsVariableRateShading();
    static bool supportsMeshShaders();
    static bool supportsComputeShaders();
    
    static TArray<ERHIBackend> getSupportedBackends();
    static uint64 getTotalSystemMemory();
    static uint64 getTotalVideoMemory();
};
```

#### å¹³å°ç‰¹å®šä¼˜åŒ–
```cpp
#if PLATFORM_WINDOWS
    // Windowsç‰¹å®šä¼˜åŒ–
    #include <d3d12.h>
    #include <dxgi1_6.h>
#elif PLATFORM_LINUX  
    // Linuxç‰¹å®šä¼˜åŒ–
    #include <X11/Xlib.h>
    #include <vulkan/vulkan_xlib.h>
#elif PLATFORM_ANDROID
    // Androidç‰¹å®šä¼˜åŒ–
    #include <android/native_window.h>
    #include <vulkan/vulkan_android.h>
#endif
```

### 4. ç€è‰²å™¨ç³»ç»Ÿæ‰©å±•

#### è·¨å¹³å°ç€è‰²å™¨ç¼–è¯‘
```cpp
class ShaderCompiler {
public:
    struct CompileOptions {
        EShaderStage stage;
        String entryPoint = "main";
        String targetProfile;  // "vs_5_0", "ps_5_0", etc.
        TMap<String, String> defines;
        bool generateDebugInfo = false;
    };
    
    virtual TArray<uint8> compileFromSource(
        const String& source, 
        const CompileOptions& options
    ) = 0;
    
    virtual TArray<uint8> compileFromFile(
        const String& filePath,
        const CompileOptions& options  
    ) = 0;
};

class HLSLCompiler : public ShaderCompiler { /* å®ç°HLSLç¼–è¯‘ */ };
class GLSLCompiler : public ShaderCompiler { /* å®ç°GLSLç¼–è¯‘ */ };
```

#### ç€è‰²å™¨åå°„å’Œç»‘å®š
```cpp
class ShaderReflection {
public:
    struct ConstantBuffer {
        String name;
        uint32 bindPoint;
        uint32 size;
        TArray<ShaderVariable> variables;
    };
    
    struct ShaderResource {
        String name;
        uint32 bindPoint;
        EResourceType type;
    };
    
    TArray<ConstantBuffer> getConstantBuffers() const;
    TArray<ShaderResource> getShaderResources() const;
};
```

---

## æ€»ç»“

MonsterEngineé‡‡ç”¨äº†ç°ä»£åŒ–çš„æ¶æ„è®¾è®¡ï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

### æ¶æ„ä¼˜åŠ¿

1. **åˆ†å±‚æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚è®¾è®¡ä½¿å¾—å„ä¸ªæ¨¡å—èŒè´£æ˜ç¡®ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **è·¨å¹³å°æŠ½è±¡**: RHIå±‚æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œå±è”½ä¸åŒå›¾å½¢APIçš„å·®å¼‚
3. **ç°ä»£C++**: å……åˆ†åˆ©ç”¨C++20ç‰¹æ€§ï¼Œæä¾›ç±»å‹å®‰å…¨å’Œé«˜æ€§èƒ½
4. **æ¨¡å—åŒ–è®¾è®¡**: æ¯ä¸ªæ¨¡å—éƒ½å¯ä»¥ç‹¬ç«‹å¼€å‘å’Œæµ‹è¯•
5. **æ‰©å±•æ€§å¼º**: æ˜“äºæ·»åŠ æ–°çš„å›¾å½¢APIåç«¯å’Œæ¸²æŸ“åŠŸèƒ½

### è®¾è®¡ç‰¹ç‚¹

- **RAIIèµ„æºç®¡ç†**: è‡ªåŠ¨åŒ–çš„èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†
- **æ™ºèƒ½æŒ‡é’ˆ**: é¿å…å†…å­˜æ³„æ¼å’Œæ‚¬ç©ºæŒ‡é’ˆ
- **å·¥å‚æ¨¡å¼**: æ”¯æŒè¿è¡Œæ—¶åç«¯é€‰æ‹©
- **æ¥å£éš”ç¦»**: ä¸“ç”¨æ¥å£æé«˜ä»£ç å¯ç»´æŠ¤æ€§
- **æ€§èƒ½ä¼˜åŒ–**: GPUé©±åŠ¨æ¸²æŸ“å’Œå¤šçº¿ç¨‹æ”¯æŒ

### æœªæ¥å‘å±•

MonsterEngineä¸ºæœªæ¥çš„æ‰©å±•æä¾›äº†è‰¯å¥½çš„åŸºç¡€ï¼š

- æ”¯æŒæ›´å¤šå›¾å½¢API (D3D12, D3D11, OpenGL, Metal)
- é«˜çº§æ¸²æŸ“åŠŸèƒ½ (PBR, å…‰çº¿è¿½è¸ª, è®¡ç®—ç€è‰²å™¨)
- è·¨å¹³å°æ”¯æŒ (Linux, Android, iOS, macOS)
- ç°ä»£æ¸²æŸ“æŠ€æœ¯ (ç½‘æ ¼ç€è‰²å™¨, å¯å˜é€Ÿç‡ç€è‰²)
- æ€§èƒ½ä¼˜åŒ– (GPUé©±åŠ¨æ¸²æŸ“, å¤šçº¿ç¨‹å‘½ä»¤ç”Ÿæˆ)

è¿™ä¸ªå¼•æ“æ¶æ„ä¸ºç°ä»£æ¸¸æˆå’Œå®æ—¶æ¸²æŸ“åº”ç”¨æä¾›äº†ä¸€ä¸ªåšå®çš„æŠ€æœ¯åŸºç¡€ï¼ŒåŒæ—¶ä¿æŒäº†è¶³å¤Ÿçš„çµæ´»æ€§æ¥é€‚åº”æœªæ¥çš„æŠ€æœ¯å‘å±•ã€‚

---

## æœ€æ–°å¼€å‘è¿›å±•

### VulkanDevice å®Œæ•´å®ç° (2025å¹´9æœˆ21æ—¥)

æœ¬æ¬¡å¼€å‘å®Œæˆäº† VulkanDevice.cpp ä¸­æ‰€æœ‰æ ¸å¿ƒå‡½æ•°çš„å®Œæ•´å®ç°ï¼Œæ ‡å¿—ç€ MonsterEngine çš„ Vulkan åç«¯ä»æ¡†æ¶è®¾è®¡è½¬å‘å®é™…å¯ç”¨çš„å®ç°ã€‚

#### ğŸš€ ä¸»è¦å®ç°å†…å®¹

##### 1. Vulkan å®ä¾‹ç®¡ç†
```cpp
// Vulkan å®ä¾‹åˆ›å»ºå’Œé…ç½®
bool VulkanDevice::createInstance(const RHICreateInfo& createInfo) {
    // âœ… å®Œæ•´çš„ Vulkan å®ä¾‹åˆ›å»ºæµç¨‹
    // âœ… éªŒè¯å±‚æ”¯æŒæ£€æŸ¥
    // âœ… æ‰©å±•ç®¡ç† (å¹³å°ç‰¹å®š)
    // âœ… è°ƒè¯•ä¿¡æ¯é…ç½®
}
```

**æ ¸å¿ƒç‰¹æ€§**:
- è·¨å¹³å°æ‰©å±•æ”¯æŒ (Windows/Linux)
- éªŒè¯å±‚åŠ¨æ€å¯ç”¨/ç¦ç”¨
- å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- è°ƒè¯•æ¶ˆæ¯å™¨è‡ªåŠ¨é…ç½®

##### 2. ç‰©ç†è®¾å¤‡é€‰æ‹©ç®—æ³•
```cpp
// æ™ºèƒ½è®¾å¤‡é€‰æ‹©å’Œè¯„ä¼°
bool VulkanDevice::selectPhysicalDevice() {
    // âœ… å¤š GPU ç¯å¢ƒä¸‹çš„è®¾å¤‡æšä¸¾
    // âœ… è®¾å¤‡é€‚ç”¨æ€§è¯„ä¼°ç®—æ³•
    // âœ… é˜Ÿåˆ—æ—æ”¯æŒæ£€æŸ¥
    // âœ… æ‰©å±•å…¼å®¹æ€§éªŒè¯
}
```

**é€‰æ‹©æ ‡å‡†**:
- é˜Ÿåˆ—æ—æ”¯æŒ (å›¾å½¢ã€å‘ˆç°)
- å¿…éœ€æ‰©å±•æ”¯æŒ
- äº¤æ¢é“¾å…¼å®¹æ€§
- è®¾å¤‡ç‰¹æ€§æ”¯æŒ

##### 3. é€»è¾‘è®¾å¤‡å’Œé˜Ÿåˆ—ç®¡ç†
```cpp
// é€»è¾‘è®¾å¤‡åˆ›å»ºå’Œé˜Ÿåˆ—è·å–
bool VulkanDevice::createLogicalDevice() {
    // âœ… é˜Ÿåˆ—æ—å‘ç°å’Œé…ç½®
    // âœ… è®¾å¤‡ç‰¹æ€§å¯ç”¨
    // âœ… æ‰©å±•æ¿€æ´»
    // âœ… é˜Ÿåˆ—å¥æŸ„è·å–
}
```

**é˜Ÿåˆ—æ¶æ„**:
- å›¾å½¢é˜Ÿåˆ—: ä¸»è¦æ¸²æŸ“å‘½ä»¤
- å‘ˆç°é˜Ÿåˆ—: äº¤æ¢é“¾å‘ˆç°
- ç»Ÿä¸€æˆ–åˆ†ç¦»é˜Ÿåˆ—æ”¯æŒ

##### 4. äº¤æ¢é“¾å®Œæ•´å®ç°
```cpp
// é«˜çº§äº¤æ¢é“¾ç®¡ç†
bool VulkanDevice::createSwapchain(const RHICreateInfo& createInfo) {
    // âœ… è¡¨é¢èƒ½åŠ›æŸ¥è¯¢
    // âœ… æ ¼å¼å’Œå‘ˆç°æ¨¡å¼é€‰æ‹©
    // âœ… å›¾åƒè§†å›¾åˆ›å»º
    // âœ… å¤šé‡ç¼“å†²æ”¯æŒ
}
```

**äº¤æ¢é“¾ç‰¹æ€§**:
- è‡ªé€‚åº”æ ¼å¼é€‰æ‹© (ä¼˜å…ˆ SRGB)
- å‘ˆç°æ¨¡å¼ä¼˜åŒ– (Mailbox > FIFO)
- åŠ¨æ€åˆ†è¾¨ç‡è°ƒæ•´
- å›¾åƒè§†å›¾è‡ªåŠ¨ç®¡ç†

##### 5. å‘½ä»¤ç³»ç»Ÿæ¶æ„
```cpp
// å‘½ä»¤æ± å’Œå‘½ä»¤åˆ—è¡¨ç®¡ç†
bool VulkanDevice::createCommandPool() {
    // âœ… çº¿ç¨‹å®‰å…¨çš„å‘½ä»¤æ± 
    // âœ… å³æ—¶å‘½ä»¤åˆ—è¡¨åˆ›å»º
    // âœ… å‘½ä»¤ç¼“å†²åŒºé‡ç½®æ”¯æŒ
}

void VulkanDevice::executeCommandLists(TSpan<TSharedPtr<IRHICommandList>> commandLists) {
    // âœ… æ‰¹é‡å‘½ä»¤æäº¤
    // âœ… ç±»å‹å®‰å…¨çš„è½¬æ¢
    // âœ… é˜Ÿåˆ—åŒæ­¥
}
```

##### 6. åŒæ­¥åŸè¯­ç³»ç»Ÿ
```cpp
// å®Œæ•´çš„ GPU-CPU åŒæ­¥
bool VulkanDevice::createSyncObjects() {
    // âœ… ä¿¡å·é‡åˆ›å»º (å›¾åƒå¯ç”¨/æ¸²æŸ“å®Œæˆ)
    // âœ… æ …æ ç®¡ç† (å¸§åŒæ­¥)
    // âœ… å¤šå¸§å¹¶è¡Œæ”¯æŒ
}
```

**åŒæ­¥ç­–ç•¥**:
- åŒé‡ç¼“å†²/ä¸‰é‡ç¼“å†²æ”¯æŒ
- å¸§é—´ä¾èµ–ç®¡ç†
- GPU-CPU åŒæ­¥ä¼˜åŒ–

##### 7. å‘ˆç°å¾ªç¯å®ç°
```cpp
// å®Œæ•´çš„å‘ˆç°ç®¡é“
void VulkanDevice::present() {
    // âœ… å¸§åŒæ­¥ç­‰å¾…
    // âœ… äº¤æ¢é“¾å›¾åƒè·å–
    // âœ… å‘ˆç°é˜Ÿåˆ—æäº¤
    // âœ… é”™è¯¯å¤„ç†å’Œæ¢å¤
}
```

#### ğŸ”§ è¾…åŠ©ç³»ç»Ÿå®ç°

##### è®¾å¤‡èƒ½åŠ›æŸ¥è¯¢ç³»ç»Ÿ
```cpp
void VulkanDevice::queryCapabilities() {
    // âœ… å®æ—¶è®¾å¤‡ä¿¡æ¯è·å–
    // âœ… ä¾›åº”å•†è¯†åˆ« (NVIDIA/AMD/Intel/ARM/Qualcomm)
    // âœ… å†…å­˜ç»Ÿè®¡å’Œåˆ†ç±»
    // âœ… ç‰¹æ€§æ”¯æŒæ£€æµ‹
    // âœ… é™åˆ¶å‚æ•°æ˜ å°„
}
```

**èƒ½åŠ›æ£€æµ‹è¦†ç›–**:
- çº¹ç†å°ºå¯¸é™åˆ¶
- æ¸²æŸ“ç›®æ ‡æ•°é‡
- å‡ ä½•ç€è‰²å™¨æ”¯æŒ
- ç»†åˆ†ç€è‰²å™¨æ”¯æŒ
- è®¡ç®—ç€è‰²å™¨æ”¯æŒ
- å¤šé‡ç»˜åˆ¶æ”¯æŒ
- æ—¶é—´æˆ³æŸ¥è¯¢æ”¯æŒ

##### éªŒè¯å’Œè°ƒè¯•ç³»ç»Ÿ
```cpp
// å¼€å‘å‹å¥½çš„è°ƒè¯•æ”¯æŒ
bool VulkanDevice::checkValidationLayerSupport() {
    // âœ… è¿è¡Œæ—¶éªŒè¯å±‚æ£€æŸ¥
    // âœ… å±‚å¯ç”¨æ€§éªŒè¯
}

bool VulkanDevice::setupDebugMessenger() {
    // âœ… è°ƒè¯•æ¶ˆæ¯å›è°ƒè®¾ç½®
    // âœ… æ¶ˆæ¯ä¸¥é‡æ€§è¿‡æ»¤
    // âœ… è‡ªå®šä¹‰æ—¥å¿—é›†æˆ
}
```

#### ğŸ“Š å®ç°ç»Ÿè®¡

| åŠŸèƒ½æ¨¡å— | å®ç°çŠ¶æ€ | ä»£ç è¡Œæ•° | å®Œæˆåº¦ |
|---------|---------|---------|-------|
| å®ä¾‹ç®¡ç† | âœ… å®Œæˆ | ~80 è¡Œ | 100% |
| è®¾å¤‡é€‰æ‹© | âœ… å®Œæˆ | ~60 è¡Œ | 100% |
| é€»è¾‘è®¾å¤‡ | âœ… å®Œæˆ | ~90 è¡Œ | 100% |
| äº¤æ¢é“¾ | âœ… å®Œæˆ | ~120 è¡Œ | 100% |
| å‘½ä»¤ç³»ç»Ÿ | âœ… å®Œæˆ | ~50 è¡Œ | 90% |
| åŒæ­¥å¯¹è±¡ | âœ… å®Œæˆ | ~40 è¡Œ | 100% |
| å‘ˆç°å¾ªç¯ | âœ… å®Œæˆ | ~60 è¡Œ | 95% |
| èƒ½åŠ›æŸ¥è¯¢ | âœ… å®Œæˆ | ~70 è¡Œ | 100% |
| è°ƒè¯•æ”¯æŒ | âœ… å®Œæˆ | ~40 è¡Œ | 100% |
| **æ€»è®¡** | **9/9 å®Œæˆ** | **~610 è¡Œ** | **98%** |

#### ğŸ¯ æ¶æ„ä¼˜åŠ¿

##### 1. é”™è¯¯å¤„ç†ç­–ç•¥
- **åˆ†å±‚é”™è¯¯å¤„ç†**: æ¯ä¸ªå‡½æ•°éƒ½æœ‰å®Œæ•´çš„é”™è¯¯æ£€æŸ¥
- **graceful degradation**: ç¼ºå°‘åŠŸèƒ½æ—¶ä¼˜é›…é™çº§
- **è¯¦ç»†æ—¥å¿—è®°å½•**: æ‰€æœ‰å…³é”®æ“ä½œéƒ½æœ‰æ—¥å¿—è·Ÿè¸ª

##### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–
- **RAII åŸåˆ™**: æ‰€æœ‰ Vulkan å¯¹è±¡è‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
- **æ™ºèƒ½æŒ‡é’ˆ**: é¿å…å†…å­˜æ³„æ¼å’Œæ‚¬ç©ºæŒ‡é’ˆ
- **èµ„æºè·Ÿè¸ª**: å®Œæ•´çš„åˆ›å»º/é”€æ¯é…å¯¹

##### 3. æ€§èƒ½è€ƒè™‘
- **æ‰¹é‡æ“ä½œ**: å‘½ä»¤åˆ—è¡¨æ‰¹é‡æäº¤å‡å°‘è°ƒç”¨å¼€é”€
- **å¹¶è¡Œæ¸²æŸ“**: å¤šå¸§å¹¶è¡Œæ”¯æŒæé«˜ GPU åˆ©ç”¨ç‡
- **ä¼˜åŒ–é€‰æ‹©**: è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çš„å‘ˆç°æ¨¡å¼å’Œæ ¼å¼

#### ğŸ”® åç»­å¼€å‘è®¡åˆ’

##### çŸ­æœŸç›®æ ‡ (1-2å‘¨)
- **ç®¡é“çŠ¶æ€å®ç°**: å®Œæˆ `createPipelineState()` åŠŸèƒ½
- **æ¸²æŸ“é€šé“**: å®ç° Vulkan æ¸²æŸ“é€šé“ç®¡ç†
- **æè¿°ç¬¦é›†**: å®ç°èµ„æºç»‘å®šç³»ç»Ÿ

##### ä¸­æœŸç›®æ ‡ (1ä¸ªæœˆ)
- **ç€è‰²å™¨ç¼–è¯‘**: é›†æˆ HLSL->SPIR-V ç¼–è¯‘ç®¡é“
- **èµ„æºç®¡ç†**: å®Œå–„ç¼“å†²åŒºå’Œçº¹ç†å®ç°
- **çª—å£ç³»ç»Ÿ**: é›†æˆå®é™…çš„çª—å£åˆ›å»º

##### é•¿æœŸç›®æ ‡ (3ä¸ªæœˆ)
- **å¤šçº¿ç¨‹ä¼˜åŒ–**: å¹¶è¡Œå‘½ä»¤åˆ—è¡¨ç”Ÿæˆ
- **é«˜çº§ç‰¹æ€§**: è®¡ç®—ç€è‰²å™¨ã€å‡ ä½•ç€è‰²å™¨æ”¯æŒ
- **å¹³å°æ‰©å±•**: Linux å’Œ Android æ”¯æŒ

#### ğŸ’¡ æŠ€æœ¯äº®ç‚¹

1. **ç°ä»£ C++ è®¾è®¡**
   - å¹¿æ³›ä½¿ç”¨ C++20 ç‰¹æ€§
   - RAII å’Œæ™ºèƒ½æŒ‡é’ˆ
   - å¼ºç±»å‹å®‰å…¨

2. **è·¨å¹³å°æ¶æ„**
   - å¹³å°ç‰¹å®šä»£ç éš”ç¦»
   - ç»Ÿä¸€çš„æ¥å£æŠ½è±¡
   - ç¼–è¯‘æ—¶å¹³å°æ£€æµ‹

3. **è°ƒè¯•å‹å¥½**
   - è¯¦ç»†çš„æ—¥å¿—è¾“å‡º
   - éªŒè¯å±‚é›†æˆ
   - é”™è¯¯è¿½è¸ªæ”¯æŒ

4. **å¯ç»´æŠ¤æ€§**
   - æ¸…æ™°çš„å‡½æ•°åˆ†ç¦»
   - å®Œæ•´çš„æ–‡æ¡£æ³¨é‡Š
   - ä¸€è‡´çš„é”™è¯¯å¤„ç†

è¿™æ¬¡å®ç°æ ‡å¿—ç€ MonsterEngine ä»æ¦‚å¿µåŸå‹è½¬å‘å®é™…å¯ç”¨çš„æ¸²æŸ“å¼•æ“ï¼Œä¸ºåç»­çš„é«˜çº§æ¸²æŸ“åŠŸèƒ½å¼€å‘å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚

---

*æœ¬æ–‡æ¡£ç”Ÿæˆæ—¶é—´: 2025å¹´9æœˆ21æ—¥*
*MonsterEngineç‰ˆæœ¬: å¼€å‘ç‰ˆæœ¬ v0.2.0*
*ä½œè€…: MonsterEngineå¼€å‘å›¢é˜Ÿ*
*æœ€åæ›´æ–°: VulkanDevice å®Œæ•´å®ç°*
