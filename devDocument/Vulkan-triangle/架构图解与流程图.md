# MonsterRender Vulkan RHI 架构图解

## 文档概述

本文档使用图表可视化 MonsterRender 引擎的 Vulkan RHI 架构，包括类关系图、流程图和时序图。

**文档版本**: 1.0  
**创建日期**: 2025-11-19

---

## 目录

1. [系统架构图](#系统架构图)
2. [类关系图](#类关系图)
3. [渲染流程图](#渲染流程图)
4. [时序图](#时序图)
5. [状态机图](#状态机图)

---

## 系统架构图

### 1. 整体分层架构

```mermaid
graph TB
    subgraph APP["应用层 (Application Layer)"]
        A1[TriangleApplication]
        A2[TriangleRenderer]
        A3[其他应用类]
    end
    
    subgraph RHI["RHI 抽象层 (RHI Abstraction)"]
        R1[IRHIDevice]
        R2[IRHICommandList]
        R3[IRHIBuffer]
        R4[IRHITexture]
        R5[IRHIPipelineState]
        R6[IRHIShader]
    end
    
    subgraph VK["Vulkan 实现层 (Vulkan Backend)"]
        V1[VulkanDevice]
        V2[FVulkanRHICommandListImmediate]
        V3[FVulkanCommandListContext]
        V4[VulkanBuffer]
        V5[VulkanTexture]
        V6[VulkanPipelineState]
        V7[VulkanShader]
        V8[FVulkanMemoryManager]
    end
    
    subgraph VKAPI["Vulkan API"]
        VK1[VkInstance]
        VK2[VkDevice]
        VK3[VkCommandBuffer]
        VK4[VkBuffer]
        VK5[VkImage]
        VK6[VkPipeline]
    end
    
    APP --> RHI
    RHI -.实现.-> VK
    VK --> VKAPI
    
    style APP fill:#90EE90
    style RHI fill:#87CEEB
    style VK fill:#FFB6C1
    style VKAPI fill:#DDA0DD
```

### 2. 命令列表系统架构

```mermaid
graph LR
    A[应用层] -->|调用| B[IRHICommandList]
    B -->|实现| C[FVulkanRHICommandListImmediate]
    C -->|委托| D[FVulkanCommandListContext]
    D -->|使用| E[FVulkanCmdBuffer]
    D -->|使用| F[FVulkanPendingState]
    D -->|使用| G[FVulkanDescriptorPool]
    E -->|封装| H[VkCommandBuffer]
    F -->|跟踪| I[管线状态/资源绑定]
    G -->|管理| J[VkDescriptorSet]
    
    style A fill:#90EE90
    style B fill:#87CEEB
    style C fill:#FFB6C1
    style D fill:#FFD700
    style E fill:#FFA500
```

---

## 类关系图

### 1. RHI 接口层次结构

```mermaid
classDiagram
    class IRHIResource {
        <<interface>>
        +getSize() uint32
        +getUsage() EResourceUsage
    }
    
    class IRHIBuffer {
        <<interface>>
        +map() void*
        +unmap() void
    }
    
    class IRHITexture {
        <<interface>>
        +getWidth() uint32
        +getHeight() uint32
        +getFormat() EPixelFormat
    }
    
    class IRHIShader {
        <<interface>>
        #m_stage EShaderStage
    }
    
    class IRHIVertexShader {
        <<interface>>
    }
    
    class IRHIPixelShader {
        <<interface>>
    }
    
    class IRHIPipelineState {
        <<interface>>
    }
    
    IRHIResource <|-- IRHIBuffer
    IRHIResource <|-- IRHITexture
    IRHIResource <|-- IRHIShader
    IRHIResource <|-- IRHIPipelineState
    IRHIShader <|-- IRHIVertexShader
    IRHIShader <|-- IRHIPixelShader
```

### 2. Vulkan 实现类层次

```mermaid
classDiagram
    class VulkanDevice {
        -VkInstance m_instance
        -VkDevice m_device
        -VkQueue m_graphicsQueue
        -VkSwapchainKHR m_swapchain
        -TUniquePtr~FVulkanMemoryManager~ m_memoryManager
        -TUniquePtr~FVulkanCommandListContext~ m_commandListContext
        +initialize() bool
        +createBuffer() TSharedPtr~IRHIBuffer~
        +present() void
    }
    
    class FVulkanRHICommandListImmediate {
        -VulkanDevice* m_device
        -FVulkanCommandListContext* m_context
        +begin() void
        +end() void
        +draw() void
    }
    
    class FVulkanCommandListContext {
        -FVulkanCmdBuffer* m_cmdBuffer
        -TUniquePtr~FVulkanPendingState~ m_pendingState
        -TUniquePtr~FVulkanDescriptorPool~ m_descriptorPool
        +prepareForNewFrame() void
        +beginRecording() void
        +submitCommands() void
    }
    
    class FVulkanCmdBuffer {
        -VkCommandBuffer m_commandBuffer
        -VkFence m_fence
        -State m_state
        +begin() void
        +end() void
        +submit() void
        +waitForFence() void
    }
    
    class FVulkanPendingState {
        -VulkanPipelineState* m_currentPipeline
        -TArray~VkBuffer~ m_vertexBuffers
        -bool m_dirty
        +setPipeline() void
        +setVertexBuffers() void
        +apply() void
    }
    
    class FVulkanMemoryManager {
        -TArray~FVulkanHeap*~ m_heaps
        +Allocate() FVulkanAllocation*
        +Free() void
    }
    
    class VulkanBuffer {
        -VkBuffer m_buffer
        -FVulkanAllocation m_allocation
        +map() void*
        +unmap() void
    }
    
    VulkanDevice --> FVulkanRHICommandListImmediate
    VulkanDevice --> FVulkanCommandListContext
    VulkanDevice --> FVulkanMemoryManager
    FVulkanRHICommandListImmediate --> FVulkanCommandListContext
    FVulkanCommandListContext --> FVulkanCmdBuffer
    FVulkanCommandListContext --> FVulkanPendingState
    VulkanBuffer --> FVulkanMemoryManager
```

### 3. 应用层类关系

```mermaid
classDiagram
    class Application {
        <<abstract>>
        #Engine* m_engine
        +run() int32
        #onInitialize()* void
        #onUpdate()* void
        #onRender()* void
        #onShutdown()* void
    }
    
    class TriangleApplication {
        -TUniquePtr~TriangleRenderer~ m_triangleRenderer
        +onInitialize() void
        +onRender() void
        +onShutdown() void
    }
    
    class TriangleRenderer {
        -IRHIDevice* m_device
        -TSharedPtr~IRHIBuffer~ m_vertexBuffer
        -TSharedPtr~IRHIVertexShader~ m_vertexShader
        -TSharedPtr~IRHIPixelShader~ m_pixelShader
        -TSharedPtr~IRHIPipelineState~ m_pipelineState
        +initialize() bool
        +render() void
    }
    
    class Engine {
        -TUniquePtr~IRHIDevice~ m_rhiDevice
        +getRHIDevice() IRHIDevice*
    }
    
    Application <|-- TriangleApplication
    TriangleApplication *-- TriangleRenderer
    TriangleApplication --> Engine
    TriangleRenderer --> IRHIDevice
```

---

## 渲染流程图

### 1. 完整渲染循环

```mermaid
flowchart TD
    Start([程序启动]) --> Init[初始化引擎]
    Init --> CreateApp[创建 TriangleApplication]
    CreateApp --> OnInit[onInitialize]
    
    OnInit --> InitRenderer[初始化 TriangleRenderer]
    InitRenderer --> CreateResources[创建渲染资源]
    CreateResources --> MainLoop{主循环运行中?}
    
    MainLoop -->|是| OnUpdate[onUpdate<br/>更新逻辑]
    OnUpdate --> OnRender[onRender<br/>渲染一帧]
    OnRender --> PrepFrame[准备新帧]
    
    PrepFrame --> BeginCmd[开始命令录制]
    BeginCmd --> SetRT[设置渲染目标]
    SetRT --> BeginRP[开始渲染通道]
    
    BeginRP --> RenderScene[渲染场景]
    RenderScene --> EndRP[结束渲染通道]
    EndRP --> EndCmd[结束命令录制]
    EndCmd --> Submit[提交到 GPU]
    Submit --> Present[呈现到屏幕]
    Present --> MainLoop
    
    MainLoop -->|否| OnShutdown[onShutdown]
    OnShutdown --> WaitGPU[等待 GPU 完成]
    WaitGPU --> Cleanup[清理资源]
    Cleanup --> End([程序结束])
    
    style Start fill:#90EE90
    style End fill:#FFB6C1
    style MainLoop fill:#87CEEB
    style RenderScene fill:#FFD700
    style Present fill:#FFA500
```

### 2. 三角形渲染详细流程

```mermaid
flowchart TD
    Start([TriangleRenderer::render]) --> SetPipe[setPipelineState<br/>设置图形管线]
    SetPipe --> MarkDirty1[标记管线状态为脏]
    
    MarkDirty1 --> SetVB[setVertexBuffers<br/>设置顶点缓冲区]
    SetVB --> MarkDirty2[标记顶点缓冲为脏]
    
    MarkDirty2 --> SetVP[setViewport<br/>设置视口]
    SetVP --> VkVP[vkCmdSetViewport]
    
    VkVP --> SetScissor[setScissorRect<br/>设置裁剪矩形]
    SetScissor --> VkScissor[vkCmdSetScissor]
    
    VkScissor --> Draw[draw<br/>绘制 3 个顶点]
    Draw --> CheckDirty{状态是脏的?}
    
    CheckDirty -->|是| ApplyState[应用待处理状态]
    CheckDirty -->|否| RecordDraw
    
    ApplyState --> BindPipe[vkCmdBindPipeline]
    BindPipe --> BindVB[vkCmdBindVertexBuffers]
    BindVB --> ClearDirty[清除脏标记]
    ClearDirty --> RecordDraw[vkCmdDraw]
    
    RecordDraw --> End([渲染完成])
    
    style Start fill:#90EE90
    style End fill:#FFB6C1
    style Draw fill:#FFD700
    style ApplyState fill:#FFA500
```

### 3. 资源创建流程

```mermaid
flowchart TD
    Start([创建 Buffer]) --> CreateDesc[定义 BufferDesc]
    CreateDesc --> CallCreate[调用 device->createBuffer]
    
    CallCreate --> VkCreate[创建 VkBuffer]
    VkCreate --> GetMemReq[查询内存需求]
    
    GetMemReq --> CheckSize{size >= 64MB?}
    CheckSize -->|是| DirectAlloc[直接分配<br/>VkDeviceMemory]
    CheckSize -->|否| SubAlloc[从内存管理器<br/>子分配]
    
    DirectAlloc --> Bind
    SubAlloc --> FindHeap[查找合适的堆]
    FindHeap --> AllocFromHeap[从堆中分配]
    AllocFromHeap --> Bind[绑定内存到 Buffer]
    
    Bind --> Map{需要映射?}
    Map -->|是| MapMem[vkMapMemory]
    Map -->|否| Return
    MapMem --> Return[返回 Buffer 对象]
    Return --> End([创建完成])
    
    style Start fill:#90EE90
    style End fill:#FFB6C1
    style CheckSize fill:#87CEEB
    style SubAlloc fill:#FFD700
```

### 4. 管线状态创建流程

```mermaid
flowchart TD
    Start([创建 PipelineState]) --> CalcHash[计算描述哈希]
    CalcHash --> CheckCache{缓存中存在?}
    
    CheckCache -->|是| CacheHit[缓存命中]
    CheckCache -->|否| CacheMiss[缓存未命中]
    
    CacheHit --> Return[返回缓存的管线]
    CacheMiss --> CreateShaderMods[创建着色器模块]
    
    CreateShaderMods --> CreateLayout[创建管线布局]
    CreateLayout --> CreateRP[创建/获取渲染通道]
    CreateRP --> SetupStates[设置各种状态]
    
    SetupStates --> SetupVtx[顶点输入状态]
    SetupVtx --> SetupIA[输入装配状态]
    SetupIA --> SetupRaster[光栅化状态]
    SetupRaster --> SetupMS[多重采样状态]
    SetupMS --> SetupBlend[混合状态]
    
    SetupBlend --> CreatePipeline[vkCreateGraphicsPipelines]
    CreatePipeline --> AddCache[添加到缓存]
    AddCache --> Return
    
    Return --> End([创建完成])
    
    style Start fill:#90EE90
    style End fill:#FFB6C1
    style CheckCache fill:#87CEEB
    style CacheHit fill:#98FB98
    style CreatePipeline fill:#FFD700
```

---

## 时序图

### 1. 帧渲染时序

```mermaid
sequenceDiagram
    participant App as TriangleApplication
    participant Renderer as TriangleRenderer
    participant Device as VulkanDevice
    participant Context as FVulkanCommandListContext
    participant CmdList as FVulkanRHICommandListImmediate
    participant GPU as GPU Queue
    
    Note over App,GPU: 帧开始
    
    App->>Device: getImmediateCommandList()
    Device-->>App: cmdList
    
    App->>Context: prepareForNewFrame()
    activate Context
    Context->>Context: 获取可用命令缓冲区
    Context->>Context: 重置状态
    deactivate Context
    
    App->>CmdList: begin()
    CmdList->>Context: beginRecording()
    
    App->>CmdList: setRenderTargets()
    CmdList->>Context: 开始渲染通道
    
    App->>Renderer: render(cmdList)
    activate Renderer
    Renderer->>CmdList: setPipelineState()
    Renderer->>CmdList: setVertexBuffers()
    Renderer->>CmdList: setViewport()
    Renderer->>CmdList: setScissorRect()
    Renderer->>CmdList: draw(3)
    activate CmdList
    CmdList->>Context: 应用待处理状态
    CmdList->>GPU: vkCmdDraw
    deactivate CmdList
    deactivate Renderer
    
    App->>CmdList: endRenderPass()
    CmdList->>Context: vkCmdEndRenderPass
    
    App->>CmdList: end()
    CmdList->>Context: endRecording()
    
    App->>Device: present()
    activate Device
    Device->>GPU: vkQueueSubmit
    Device->>GPU: vkQueuePresentKHR
    deactivate Device
    
    Note over App,GPU: 帧结束
```

### 2. 资源创建时序

```mermaid
sequenceDiagram
    participant App as Application
    participant Device as VulkanDevice
    participant Buffer as VulkanBuffer
    participant MemMgr as FVulkanMemoryManager
    participant Vulkan as Vulkan API
    
    App->>Device: createBuffer(desc)
    activate Device
    Device->>Buffer: new VulkanBuffer(desc)
    activate Buffer
    
    Buffer->>Vulkan: vkCreateBuffer()
    Vulkan-->>Buffer: VkBuffer
    
    Buffer->>Vulkan: vkGetBufferMemoryRequirements()
    Vulkan-->>Buffer: memReqs
    
    Buffer->>MemMgr: Allocate(size, typeIndex)
    activate MemMgr
    
    alt 大块分配 (>= 64MB)
        MemMgr->>Vulkan: vkAllocateMemory()
        Vulkan-->>MemMgr: VkDeviceMemory
    else 小块分配
        MemMgr->>MemMgr: 从堆中子分配
    end
    
    MemMgr-->>Buffer: FVulkanAllocation
    deactivate MemMgr
    
    Buffer->>Vulkan: vkBindBufferMemory()
    
    opt CPU 可访问
        Buffer->>Vulkan: vkMapMemory()
        Vulkan-->>Buffer: mappedPointer
    end
    
    Buffer-->>Device: VulkanBuffer
    deactivate Buffer
    Device-->>App: TSharedPtr<IRHIBuffer>
    deactivate Device
```

### 3. 同步时序（双缓冲）

```mermaid
sequenceDiagram
    participant CPU
    participant Frame0 as 帧 0 (Fence 0)
    participant Frame1 as 帧 1 (Fence 1)
    participant GPU
    participant Swapchain
    
    Note over CPU,Swapchain: 初始状态
    
    rect rgb(200, 255, 200)
    Note over CPU,GPU: 帧 0 开始
    CPU->>Frame0: vkWaitForFences (Fence 0)
    CPU->>Frame0: vkResetFences (Fence 0)
    CPU->>Swapchain: vkAcquireNextImageKHR
    Swapchain-->>CPU: imageIndex 0
    CPU->>Frame0: 录制命令
    CPU->>GPU: vkQueueSubmit (Fence 0)
    activate GPU
    CPU->>Swapchain: vkQueuePresentKHR
    end
    
    rect rgb(200, 200, 255)
    Note over CPU,GPU: 帧 1 开始
    CPU->>Frame1: vkWaitForFences (Fence 1)
    CPU->>Frame1: vkResetFences (Fence 1)
    CPU->>Swapchain: vkAcquireNextImageKHR
    Swapchain-->>CPU: imageIndex 1
    CPU->>Frame1: 录制命令
    Note right of GPU: 帧 0 仍在执行
    CPU->>GPU: vkQueueSubmit (Fence 1)
    deactivate GPU
    activate GPU
    CPU->>Swapchain: vkQueuePresentKHR
    end
    
    rect rgb(200, 255, 200)
    Note over CPU,GPU: 帧 2 (重用 Fence 0)
    CPU->>Frame0: vkWaitForFences (Fence 0)
    Note right of CPU: 等待帧 0 完成
    CPU->>Frame0: vkResetFences (Fence 0)
    CPU->>Swapchain: vkAcquireNextImageKHR
    CPU->>Frame0: 录制命令
    Note right of GPU: 帧 1 仍在执行
    CPU->>GPU: vkQueueSubmit (Fence 0)
    deactivate GPU
    activate GPU
    end
```

---

## 状态机图

### 1. 命令缓冲区状态机

```mermaid
stateDiagram-v2
    [*] --> Initial: 创建
    
    Initial --> Recording: begin()
    Recording --> Executable: end()
    Executable --> Submitted: submit()
    Submitted --> Completed: GPU 完成
    Completed --> Initial: reset()
    
    Recording --> Initial: reset() [错误恢复]
    Executable --> Initial: reset()
    
    note right of Initial
        命令缓冲区已分配
        但未开始录制
    end note
    
    note right of Recording
        正在录制命令
        可以调用 vkCmd*
    end note
    
    note right of Executable
        录制完成
        可以提交到队列
    end note
    
    note right of Submitted
        已提交到 GPU
        等待执行完成
    end note
    
    note right of Completed
        GPU 执行完成
        可以重用或销毁
    end note
```

### 2. 渲染通道状态机

```mermaid
stateDiagram-v2
    [*] --> Outside: 初始
    
    Outside --> InRenderPass: setRenderTargets()
    InRenderPass --> Outside: endRenderPass()
    
    state InRenderPass {
        [*] --> Drawing
        Drawing --> Drawing: draw() / drawIndexed()
        Drawing --> Drawing: setPipeline()
        Drawing --> Drawing: setVertexBuffers()
    }
    
    note right of Outside
        可以进行：
        - 资源转换
        - 复制操作
        - 计算着色器
    end note
    
    note right of InRenderPass
        可以进行：
        - 绘制调用
        - 设置动态状态
        - 绑定资源
    end note
```

### 3. 资源状态转换

```mermaid
stateDiagram-v2
    [*] --> Undefined: 创建
    
    Undefined --> TransferDst: 转换为传输目标
    TransferDst --> ShaderRead: 上传数据后
    
    Undefined --> ShaderRead: 直接转换
    
    ShaderRead --> TransferDst: 需要更新
    TransferDst --> ShaderRead: 更新完成
    
    ShaderRead --> ColorAttachment: 用作渲染目标
    ColorAttachment --> ShaderRead: 渲染完成
    
    ColorAttachment --> Present: 准备呈现
    Present --> ColorAttachment: 下一帧
    
    ShaderRead --> [*]: 销毁
    ColorAttachment --> [*]: 销毁
    
    note right of Undefined
        初始状态
        不能直接使用
    end note
    
    note right of TransferDst
        可以作为传输目标
        vkCmdCopyBuffer
    end note
    
    note right of ShaderRead
        可以在着色器中读取
        纹理采样
    end note
    
    note right of ColorAttachment
        可以作为颜色附件
        渲染目标
    end note
```

---

## 性能分析图

### 1. 帧时间分解

```mermaid
gantt
    title 典型帧时间分解 (60 FPS = 16.67ms)
    dateFormat X
    axisFormat %L ms
    
    section CPU
    应用逻辑         :0, 2
    命令录制         :2, 4
    资源更新         :4, 1
    
    section GPU
    等待             :0, 3
    顶点处理         :3, 2
    光栅化           :5, 3
    片段着色         :8, 4
    混合输出         :12, 1
    
    section 呈现
    交换链等待       :13, 2
    扫描输出         :15, 1.67
```

### 2. 内存分配策略对比

```mermaid
graph LR
    subgraph "传统方式（每个缓冲区独立分配）"
        T1[Buffer 1<br/>256 KB] --> TM1[VkDeviceMemory 1]
        T2[Buffer 2<br/>512 KB] --> TM2[VkDeviceMemory 2]
        T3[Buffer 3<br/>128 KB] --> TM3[VkDeviceMemory 3]
        T4[Buffer 4<br/>1 MB] --> TM4[VkDeviceMemory 4]
    end
    
    subgraph "子分配方式（内存池）"
        S1[Buffer 1<br/>256 KB]
        S2[Buffer 2<br/>512 KB]
        S3[Buffer 3<br/>128 KB]
        S4[Buffer 4<br/>1 MB]
        
        S1 --> SP[VkDeviceMemory Pool<br/>256 MB]
        S2 --> SP
        S3 --> SP
        S4 --> SP
    end
    
    style TM1 fill:#FFB6C1
    style TM2 fill:#FFB6C1
    style TM3 fill:#FFB6C1
    style TM4 fill:#FFB6C1
    style SP fill:#98FB98
```

**对比**:
- **传统方式**: 4 次 VkDeviceMemory 分配，容易达到驱动限制
- **子分配**: 1 次大块分配，内部管理多个缓冲区

---

## 总结

### 关键架构图

1. **系统分层**: 应用层 → RHI 抽象 → Vulkan 实现 → Vulkan API
2. **命令列表**: FVulkanRHICommandListImmediate → FVulkanCommandListContext → FVulkanCmdBuffer
3. **资源管理**: IRHIDevice (工厂) → VulkanBuffer/Texture → FVulkanMemoryManager

### 关键流程

1. **渲染循环**: 准备帧 → 录制命令 → 提交 → 呈现
2. **资源创建**: 描述 → Vulkan 对象 → 内存分配 → 绑定
3. **同步机制**: 围栏（CPU-GPU）+ 信号量（GPU-GPU）

### 设计模式

1. **抽象工厂**: IRHIDevice 创建各种资源
2. **外观模式**: FVulkanRHICommandListImmediate 简化接口
3. **对象池**: 命令缓冲区、描述符集重用
4. **状态模式**: 命令缓冲区状态转换

---

**文档结束**

